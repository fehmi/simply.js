<template>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.61.1/codemirror.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/theme/monokai.min.css" />

  <div id="editor">
    <ul id="file-tabs">
      <each data.files as file>
        <li filename="{file.filename}" selected="{ file.selected }" onclick="changeSelectedFile(event)">{ file.filename
          }</li>
      </each>
    </ul>

    <ul id="files">
      <slot name="files" ref:navslot></slot>
      <each data.files as file>
        <li filename="{file.filename}" selected="{ file.selected }">
          <textarea oninput="updateFile(event)">{file.content}</textarea>
        </li>
      </each>
    </ul>
  </div>

  <div id="result">
    <iframe id="result"></iframe>
    <div id="console"></div>
  </div>
</template>

<style>
  :host {
    display: flex;
    width: 960px;
    height: 450px;
  }

  slot[name=files] {
    display: none;
  }

  #editor {
    display: flex;
    flex-direction: column;
    width: 65%;
  }

  #result {
    width: 35%;
  }

  #file-tabs li {
    cursor: pointer;
  }

  #file-tabs li[selected=true] {
    cursor: default;
    pointer-events: none;
    font-weight: 600;
  }

  #file-tabs,
  #files {
    display: flex;
    list-style: none;
    padding: 0px;
    margin: 0px;
  }

  #files {
    flex: 1;
    flex-direction: column;
  }

  #files li {
    height: 100%;
    width: 100%;
    display: none;
    cursor: pointer;
  }

  #files li[selected=true] {
    display: block;
  }

  #files textarea,
  iframe#result {
    width: 100%;
    height: 100%;
  }
</style>

<script>
  class {
    data = {
      files: []
    }
    watch() {
      console.log("hey");
    }
    methods = {
      updateFile(event) {
        var filename = event.target.parentNode.getAttribute("filename");
        for (let index = 0; index < data.files.length; index++) {
          if (data.files[index]["filename"] == filename) {
            data.files[index]["content"] = event.target.value;
          }
        }
        component.methods.render();
      },
      render() {
        console.log("render");
        var indexContent = component.dom.querySelector("li[filename=index\\.html] textarea").value;

        var files = component.methods.rewriteGet("index.html", indexContent, 0).reverse();
        console.log(files);
        var blobs = [];
        var regex = /get\(.*,(\s+)?("|')(.*)("|')(\s+)?\)/gm;
        for (let index = 0; index < files.length; index++) {
          const element = files[index];
          for (const filename in element) {
            if (blobs[filename] == undefined) {
              var content = element["content"];
              let m;

              while ((m = regex.exec(content)) !== null) {
                // This is necessary to avoid infinite loops with zero-width matches
                if (m.index === regex.lastIndex) {
                  regex.lastIndex++;
                }
                content = content.replace(m[3], blobs[m[3]].blobUrl);
              }

              var blob = new Blob([content], { type: "text/html; charset=utf-8" });
              var blobUrl = URL.createObjectURL(blob);
              //content = content.replace(filename, blobUrl);
              blobs[element["filename"]] = {
                filename: element["filename"],
                blobUrl: blobUrl,
                content: content
              };
            }
          }
        }
        // debug için script'in başına template ve style kadar \n koysam
        // satır numarasını tutturabilir miyim?

        console.log(blobs);
        component.dom.querySelector("iframe").srcdoc = blobs["index.html"].content;
      },
      rewriteGet(filename, content, i) {
        var regex = /get\(.*,(\s+)?("|')(.*)("|')(\s+)?\)/gm;
        var regex2 = /get\(.*,(\s+)?("|')(.*)("|')(\s+)?\)/gm;
        var blobs = "";

        if (!component.files) {
          component.files = [];
        }

        if (!component.files[i]) {
          component.files[i] = {};
        }

        let m;
        let mm;

        while ((m = regex.exec(content)) !== null) {
          // This is necessary to avoid infinite loops with zero-width matches
          if (m.index === regex.lastIndex) {
            regex.lastIndex++;
          }
          var fn = m[3];
          var nestedComponentContent = component.dom.querySelector("li[filename=" + fn.replace(/\./g, "\\.") + "] textarea").value;

          while ((mm = regex2.exec(content)) !== null) {
            var nnestedComponentContent = component.dom.querySelector("li[filename=" + mm[3].replace(/\./g, "\\.") + "] textarea").value;
            component.methods.rewriteGet(mm[3], nnestedComponentContent, i + 1);
          }
        }
        component.files[i]["content"] = content;
        component.files[i]["filename"] = filename;
        return component.files;
      },
      changeSelectedFile(event) {
        var filename = event.target.getAttribute("filename");
        var filenameSelector = filename.replace(/\./g, "\\.");
        for (let i = 0; i < data.files.length; i++) {
          if (data.files[i]["filename"] == filename) {
            data.files[i].selected = true;
          }
          else if (data.files[i]) {
            data.files[i].selected = false;
          }
        }
      }
    }
    lifecycle = {
      beforeConstruct() {
        if (typeof CodeMirror == "undefined") {

        }
      },
      afterFirstRender() {
        var slot = component.dom.querySelector('slot[name=files]');
        var files = slot.assignedNodes()[0].querySelectorAll("textarea");
        var editors = [];

        for (let index = 0; index < files.length; index++) {
          var fileEl = files[index];
          var filename = fileEl.getAttribute("filename");
          var fileContent = fileEl.value;
          var isFileSelected = fileEl.hasAttribute("selected");
          data.files.push({
            filename: filename,
            content: fileContent,
            selected: isFileSelected
          });
        }

        var textareas = component.dom.querySelectorAll("textarea");
        for (let index = 0; index < textareas.length; index++) {
          const ta = textareas[index];
          editors[index] = CodeMirror.fromTextArea(ta, {
            lineNumbers: true,
            mode: "htmlmixed",
            theme: 'monokai'
          }).on('change', editor => {
            console.log(editor);
          });;
        }

        component.methods.render();

      },
      beforeFirstRender(template) {
        // burada template'i editleyip
        // return edebilirim
      }
    }
  }
</script>