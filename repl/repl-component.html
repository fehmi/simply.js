<html>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/codemirror@5.62.0/lib/codemirror.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/codemirror@5.62.0/addon/fold/foldgutter.css" />
<header>
	<if cond="props.title">
		<div class="inputContainer">
			<input class="title" value="{ props.title}" readonly onclick="methods.titleFocus(event);"
				oninput="methods.titleInput(event);" onchange="methods.titleRename(event);"
				onblur="methods.titleRename(event);">
			<div class="ghost-input">{props.title}</div>
		</div>
	</if>
	<div class="buttons">
		<if cond="document.location.href.indexOf('/docs/') > -1">
			<button onclick="window.open('#/playground?'+this.getRootNode().host.id)">Open in new tab</button>
		</if>
		<if cond="props.download==true">
			<button onclick="methods.download()">Download</button>
		</if>
		<if cond="props.save==true || document.location.host == 'root' || document.location.host == 'localhost' || document.location.host == '127.0.0.1'">
			<button onclick="methods.save()">Save</button>
		</if>
		<if cond="props.fullscreen==true">
			<button onclick="methods.fullscreenToggle()">Fullscreen</button>
		</if>
		
	</div>
</header>

<div id="topArea">
	<div id="editor">
		<ul id="file-tabs">
			<each of="data.files" as="file">
				<li filename="{file.filename}" selected="{ file.selected }" onclick="methods.changeSelectedFile(event);">
					<div class="inputContainer">
						<input class="filename" value="{file.filename}" readonly onclick="methods.focusFilename(event);"
							oninput="methods.inputFilename(event);" onchange="methods.renameFilename(event);"
							onblur="methods.blurFilename(event)" onkeydown="methods.renameIfEnter(event)">
						<div class="ghost-input">{file.filename}</div>
					</div>
					<!--<div class="extension">.html</div>-->
					<if cond="props.crud==true">
						<div class="delete" onclick="methods.deleteFile(event)">âœ•</div>
					</if>
				</li>
			</each>
			<if cond="props.crud==true">
				<li class="add" onclick="methods.addFile()">+</li>
			</if>
		</ul>

		<ul id="files" passive>
			<slot name="files"></slot>
		</ul>
		<span id="tidy" onclick="methods.format()">Tidy</span>
	</div>
	<div class="v-resizer" onmousedown="methods.resize(event)"></div>
	<div id="result" status="{data.resultStatus}">
		<div id="result-header">
			Result
		</div>
			<div id="addressbar" display="{props.addressbar}">
				<!-- {data.urlHistory.length} - {data.currentUrlIndex} -->
				<button :="(data.currentUrlIndex < 2) ? 'disabled' : ''" onclick="methods.goBack(event);"></button>
				<button :="(data.currentUrlIndex> data.urlHistory.length - 1) ? 'disabled' : ''"
					onclick="methods.goNext(event);"></button>
				<input type="text" value="{data.url}" id="url" onchange="methods.changeURL(event)"/>
			</div>

		<iframe id="result" name="result" :="(data.resize.x || data.resize.y) ? 'resizing' : ''"></iframe>
	</div>
</div>
<if cond="props.console==true">
	<div class="h-resizer" onmousedown="methods.resize(event)"></div>
	<div id="console">
		<label>CONSOLE <a onclick="methods.clearConsole(event)">Clear</a></label>
		<div class="messages">
			<ul>
				<each of="data.console" as="entry">
					<li class="{entry.method}">
						{entry.message}
						<if cond="entry.file">
							(
							<span class="debugLink"
								onclick="methods.openFileGotoLine('{entry.file}', '{entry.line}','{entry.char}')">{entry.file}:{entry.line}:{entry.char}
							</span>
							)
						</if>
					</li>
				</each>
			</ul>
			<div><input placeholder=">_" name="consoleEntry" onkeyup="methods.sendJStoResult(event)"></div>
		</div>
	</div>
</if>

</html>

<style>
	:host {
		display: flex;
		width: 1000px;
		height: 500px;
		border: 2px solid #dddddd;
		font-family: Arial, Helvetica, sans-serif;
		flex-direction: column;
		background-color: white;
		box-shadow: 0px 0px 25px rgb(0 0 0 / 10%);
		text-align: left;
		font-size: 13px;
		box-sizing: border-box;
		/* border-radius: 10px; */
		/* overflow: hidden; */
	}

	:host(.fullscreen) {
		position: fixed;
		width: 100%;

		left: 0;
		transform: translate(0, 0);
		max-width: unset;
		max-height: unset;
		top: 0;
	}

	header {
		background-color: #4197b9;
		color: white;
		height: 40px;
		display: flex;
		align-items: center;
		padding: 0px 10px;
		margin-left: -2px;
		width: calc(100% + 4px);
		box-sizing: border-box;
		margin-top: -2px;
		justify-content: space-between;
	}

	slot[name=files] {
		display: none;
	}

	#topArea {
		display: flex;
		/*
    height: calc(100% - 40px - "{data.topAreaHeight}");
    max-height: calc(100% - 30px);*/
		flex: 1;
		overflow: hidden;
	}

	#editor {
		display: flex;
		flex-direction: column;
		width: "{data.editorWidth}";
		min-width: 30%;
		max-width: 60%;
		position: relative;
	}

	#result {
		display: flex;
		flex-direction: column;
		border-left: 2px solid #dddddd;
		box-sizing: border-box;
		flex: 1;
	}

	#result-header {
		position: relative;
	}

	#result-header:after {
		content: "";
		display: block;
		opacity: 0;
		position: absolute;
		width: 100%;
		height: 4px;
		left: 0;
		background: linear-gradient(45deg, rgba(255, 0, 89, 1) 0%, rgba(0, 179, 255, 1) 33%, rgba(255, 0, 89, 1) 66%, rgba(0, 179, 255, 1) 100%);
		background-size: 400% 400%;
		-webkit-animation: errorBg 1s linear infinite;
		-moz-animation: errorBg 1s linear infinite;
		animation: errorBg 1s linear infinite;
		transition: all ease 250ms;
	}

	@-webkit-keyframes errorBg {
		0% {
			background-position: 100% 0%
		}

		100% {
			background-position: 15% 100%
		}
	}

	@-moz-keyframes errorBg {
		0% {
			background-position: 100% 0%
		}

		100% {
			background-position: 15% 100%
		}
	}

	@keyframes errorBg {
		0% {
			background-position: 100% 0%
		}

		100% {
			background-position: 15% 100%
		}
	}

	#result[status=loading] #result-header:after {
		opacity: 1;
	}

	.v-resizer {
		cursor: ew-resize;
		width: 1px;
		position: relative;
	}

	.v-resizer:after {
		content: "";
		display: block;
		height: 100%;
		width: 8px;
		position: absolute;
		z-index: 10;
	}

	.h-resizer {
		cursor: ns-resize;
		height: 1px;
		width: 100%;
		position: relative;
	}

	.h-resizer:after {
		content: "";
		display: block;
		width: 100%;
		height: 8px;
		position: absolute;
		left: -2px;
		z-index: 10;
	}

	#console {
		border-top: 2px solid #dddddd;
		display: flex;
		flex-direction: column;
		position: relative;
		min-height: 30px;
		height: "{data.topAreaHeight}"
	}

	#console .messages {
		list-style: none;
		font-family: monospace;
		padding: 0;
		margin: 0px;
		overflow: auto;
		position: absolute;
		top: 35px;
		left: 0;
		right: 0;
		bottom: 0;
	}

	#console .messages ul {
		list-style: none;
		font-family: monospace;
		padding: 0;
		margin: 0px;
	}

	#console .messages li {
		border-color: #d4d4d4;
		border-style: solid;
		border-width: 1px 0px;
		padding: 3px 10px;
		margin-top: -1px;
		font-size: 12px;
	}

	#console .messages li.error {
		border-color: #fed6d7;
		background-color: #fff0f0;
		color: #fc0d1b;
	}

	#console .messages li.warn {
		border-color: #f3e5a7;
		background-color: #fffbe6;
		color: #5c3c08;
	}

	#console label {
		background-color: #f1f1f1;
		width: 100%;
		display: block;
		font-family: monospace;
		font-size: 14px;
		padding: 5px 10px;
		box-sizing: border-box;
		color: #666666;
		position: sticky;
		top: 0px;
	}

	input[name=consoleEntry] {
		font-family: monospace;
		border: none;
		padding: 5px 10px;
		font-size: 12px;
		outline: none;
		width: 100%;
		box-sizing: border-box;
	}

	#file-tabs {
		/* border-bottom: 2px solid #dddddd; */
		line-height: 35px;
		overflow: overlay;
		-webkit-background-clip: text;
		background-clip: text;
		background-color: rgba(0, 0, 0, 0);
		transition: background-color .8s;
		height: 35px;
		position: relative;
	}

	#file-tabs:before {
		content: "";
		width: 100%;
		position: absolute;
		background-color: #f1f1f1;
		height: 100%;
	}

	.CodeMirror-vscrollbar,
	.CodeMirror-hscrollbar {
		-webkit-background-clip: text;
		background-clip: text;
		background-color: rgba(0, 0, 0, 0);
		transition: background-color .8s;
	}

	#file-tabs::-webkit-scrollbar,
	.CodeMirror-hscrollbar::-webkit-scrollbar {
		width: 5px;
		height: 5px;
	}

	.CodeMirror-vscrollbar::-webkit-scrollbar {
		width: 10px;
	}

	.CodeMirror-hscrollbar::-webkit-scrollbar {
		height: 10px;
	}

	#file-tabs::-webkit-scrollbar-track,
	.CodeMirror-vscrollbar::-webkit-scrollbar-track,
	.CodeMirror-hscrollbar::-webkit-scrollbar-track {
		background-color: transparent;

	}

	#file-tabs::-webkit-scrollbar-thumb,
	.CodeMirror-vscrollbar::-webkit-scrollbar-thumb,
	.CodeMirror-hscrollbar::-webkit-scrollbar-thumb {
		background-color: rgb(206, 206, 206);
	}


	#file-tabs::-webkit-scrollbar-thumb,
	.CodeMirror-vscrollbar::-webkit-scrollbar-thumb,
	.CodeMirror-hscrollbar::-webkit-scrollbar-thumb {
		background-color: inherit;
	}

	#file-tabs:hover,
	.CodeMirror:hover .CodeMirror-vscrollbar,
	.CodeMirror:hover .CodeMirror-hscrollbar {
		background-color: rgb(206, 206, 206);
	}

	.CodeMirror-linenumber.CodeMirror-gutter-elt {
		transform: translateX(-20px);
	}

	.CodeMirror-lines {
		padding-left: 20px;
		padding-top: 20px;
		width: calc(100%);
	}

	.CodeMirror-scroll {
		margin-right: -25px;
	}

	#file-tabs li {
		position: relative;
		cursor: pointer;
		padding: 0px 10px 0px 15px;
		font-size: 14px;
		color: #888;
		white-space: nowrap;
		background-color: #f1f1f1;
		display: flex;
	}

	#file-tabs .add {
		font-size: 22px;
		padding: 0px 10px 0px 10px;
	}

	#file-tabs .delete {
		opacity: 0;
		pointer-events: none;
		transition: opacity 500ms;
		font-size: 12px;
		margin-left: 10px;
	}

	#file-tabs li[selected=true] .delete {
		opacity: 1;
		pointer-events: all;
		cursor: pointer;
	}

	#file-tabs li[selected=false]:hover .delete {
		opacity: 1;
		pointer-events: all;
	}

	#file-tabs li:first-child input {
		pointer-events: none;
	}

	#file-tabs li:first-child .delete {
		pointer-events: none;
		display: none;
	}


	#file-tabs li[selected=true] {
		cursor: default;
		background-color: white;
		color: #4197b9;
	}

	#file-tabs li.focus .delete {
		visibility: hidden;
		pointer-events: none;
		cursor: default;
	}

	#file-tabs li.focus .extension {
		color: #888888;
	}

	.inputContainer {
		position: relative;
		flex: 1;
	}

	input.filename {
		position: absolute;
		width: 100%;
		padding: 0;
		margin-top: 10px;
		border: none;
		cursor: pointer;
		outline: none;
		background-color: transparent;
		color: #888888;
	}

	#file-tabs li[selected=true] input.filename {
		cursor: text;
		color: #4197b9;
	}

	.ghost-input {
		font-size: 13.3333px;
		min-width: 3px;
	}

	input.title {
		position: absolute;
		width: 100%;
		padding: 0;
		outline: 0;
		border: none;
		font-size: 16px;
		background: none;
		color: white;
		z-index: 1;
		margin-top: -9px;
	}

	input.title+.ghost-input {
		font-size: 16px;
		z-index: 0;
		opacity: 0;
		height: 0px;
		padding-right: 50px;
	}

	/*
  #file-tabs li[selected=true]::after {
    content: "";
    position: absolute;
    width: 100%;
    height: 3px;
    background-color: #292;
    bottom: 0px;
    left: 0px;
  }
  */

	#result-header {
		border-bottom: 2px solid #dddddd;
		line-height: 35px;
		font-size: 14px;
		padding: 0px 15px;
	}

	#file-tabs,
	#files {
		display: flex;
		list-style: none;
		padding: 0px;
		margin: 0px;
	}

	#files {
		flex: 1;
		flex-direction: column;
		height: 0px;
		position: relative;
	}

	#tidy {
		position: absolute;
    right: 13px;
    z-index: 2;
    cursor: pointer;
    top: 3px;
    opacity: .5;	
	}

	#tidy:hover {
    opacity: 1;	
	}	

	.CodeMirror {
		height: 100%;
		width: 100%;
		display: none;
		line-height: 20px;
	}

	.CodeMirror[selected=true] {
		display: block;
	}

	#files textarea,
	iframe#result {
		width: 100%;
		height: 100%;
		border: none;
	}

	iframe#result[resizing] {
		pointer-events: none;
	}

	div#addressbar[display=false] {
		display: none;
	}

	#addressbar {
		display: none;
	}

	#addressbar[display=true] {
		display: flex;
		align-items: center;
	}

	#addressbar button {
		background-size: contain;
		background-repeat: no-repeat;
		width: 17px;
		height: 17px;
		border: none;
		cursor: pointer;
	}

	#addressbar button:disabled {
		opacity: .4;
		cursor: default;
	}

	#addressbar button:nth-child(1) {
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'%3E%3Ctitle%3Eicon-arrow-left%3C/title%3E%3Cpolyline points='20.6 8 5.62 24.1 20.6 40.2' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/polyline%3E%3Cline x1='7.53' y1='24.1' x2='42.33' y2='24.1' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/line%3E%3C/svg%3E");
		margin-right: 10px;
	}

	#addressbar button:nth-child(2) {
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'%3E%3Ctitle%3Eicon-arrow-right%3C/title%3E%3Cpolyline points='27.35 40.2 42.33 24.1 27.35 8' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/polyline%3E%3Cline x1='40.42' y1='24.1' x2='5.62' y2='24.1' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/line%3E%3C/svg%3E");
	}

	div#addressbar {
		background-color: #f2f3f7;
		border-bottom: 1px solid #ced0dd;
		padding: 10px 10px;
	}

	input#url {
		flex: 1;
		border-radius: 3px;
		outline: none;
		box-shadow: none;
		border: 1px solid #ced0dd;
		padding: 0px 10px;
		line-height: 26px;
		font-size: 14px;
		margin-left: 10px;
		transition: all ease-in .1s;
	}

	input#url:focus {
		border: 1px solid #9ec5ef;
		box-shadow: 0 2px 8px 0 rgb(0 0 0 / 8%);
	}

	.debugLink {
		color: black;
		text-decoration: underline;
		cursor: pointer;
	}

	.activeline {
		position: relative;
		background-color: rgba(0, 0, 0, .04);
	}

	/* word wrap */
	.cke_reset_all .CodeMirror-scroll * {
		white-space: pre-wrap;
	}

	.CodeMirror-gutter-elt {
		position: absolute;
		cursor: default;
		z-index: 4;
		transform: translateX(-21px);
	}
</style>

<script>
	class {
		data = {
			files: [],
			url: "/",
			urlHistory: [
				"/"
			],
			currentUrlIndex: 1,
			console: [],
			resize: {
				x: false,
				y: false
			},
			editorWidth: "65%",
			topAreaHeight: "120px",
			resultStatus: "init",
			URLShortening: {
				short: "https://fozuse.com/short/shorten/",
				redirect: "https://fozuse.com/short/redirect/?url="
			}
		}
		methods = {
			renderResult() {
				// index.html'deki get'leri rewrite'a gÃ¶nderiyor
				var indexContent = component.editors["index.html"].getValue();
				var files = component.methods.getFiles("index.html", indexContent);
				// her render'dan Ã¶nce Ã¶nceki blob'larÄ± siliyor
				if (component.blobs) {
					for (let index = 0; index < Object.keys(component.blobs).length; index++) {
						let url = component.blobs[Object.keys(component.blobs)[index]].blobUrl;
						URL.revokeObjectURL(url);
					}
				}

				// yeni blob'lar iÃ§in kap
				component.blobs = [];
				var blobs = component.blobs;

				// burada getFiles'dan tÃ¼m dosyalarÄ±n iÃ§indeki
				// get(url) leri bloburl ile replace ediyoruz
				for (let index = 0; index < Object.keys(files).length; index++) {
					var file = files[Object.keys(files).reverse()[index]];
					for (const filename in file) {
						if (blobs[filename] == undefined) {
							var newContent = file["content"];
							var m;
							var regex = /(?<!\/\/(\s+)?)get\((\s+)?(\[)?([\s\S]*?)?(\,)?(\s+)?\]?(\s+)?\)(\;)?/gm;
							var cssImport = /@import\s+(\"|\')(.*)(\"|\');/gm;
							var linkCss = /<link.*href\=(\"|\')(.*)(\"|\')/gm;

							while ((m = regex.exec(file["content"])) !== null) {
								// This is necessary to avoid infinite loops with zero-width matches
								if (m.index === regex.lastIndex) {
									regex.lastIndex++;
								}
								if (m[3]) { // multi array
									var filenames = m[4].replace(/((\\n)|[\\\s\"\[\]])/g, "");
									var filenames = filenames.split(",");
									var get = m[0];
									var newGet = "";
									for (let i = 0; i < filenames.length; i++) {
										var fn = filenames[i].replace(/\'\"/g, '');
										if (component.files[fn]) {
											newGet += "get('" + blobs[fn].blobUrl + "', '" + fn + "');";
										}
										else {
											// real url in array
											newGet += "get('" + fn + "');";
										}
									}
									newContent = newContent.replace(get, newGet);
								}
								else if (m[4].indexOf(",") > -1) { // custom name
									var fileAndCustomName = m[4].replace(/((\\n)|[\\\s\"\[\]])/g, "").split(",");
									var fn = fileAndCustomName[0]
									var cn = fileAndCustomName[1] + ".html";
									var get = m[0];

									// virtual dosya ise
									if (component.files[fn]) {
										var newGet = "get('" + blobs[fn].blobUrl + "', '" + cn + "');";
										newContent = newContent.replace(get, newGet);
									}
									else {
										continue;
									}
								}
								// test
								else { // single
									var fn = m[4].slice(0, -1).replace(/((\\n)|[\\\s\"\[\]])/g, "");;
									var get = m[0];
									// console.log(fn);

									// virtual dosya ise
									if (component.files[fn]) {
										var newGet = "get('" + blobs[fn].blobUrl + "', '" + fn + "');";
										newContent = newContent.replace(get, newGet);
									}
									else {
										continue;
									}
								}
							}

							while ((m = cssImport.exec(file["content"])) !== null) {
								// This is necessary to avoid infinite loops with zero-width matches
								if (m.index === cssImport.lastIndex) {
									cssImport.lastIndex++;
								}
								var fn = m[2];
								// virtual dosya ise
								if (component.files[fn]) {
									var newImport = "@import '" + blobs[fn].blobUrl + "';";;
									newContent = newContent.replace(m[0], newImport);
								}
								else {
									console.log("yoh");
									delete blobs[fn];
									continue;
								}
							}

							while ((m = linkCss.exec(file["content"])) !== null) {
								// This is necessary to avoid infinite loops with zero-width matches
								if (m.index === linkCss.lastIndex) {
									linkCss.lastIndex++;
								}
								var fn = m[2];
								// virtual dosya ise
								if (component.files[fn]) {
									var newLink = "<link rel='stylesheet' href='" + blobs[fn].blobUrl + "'";
									newContent = newContent.replace(m[0], newLink);
								}
								else {
									delete blobs[fn];
									console.log("yoh");
									continue;
								}
							}

							var blob = new Blob([newContent], { type: "text/html; charset=utf-8" });
							var blobUrl = URL.createObjectURL(blob);

							if (document.location.host == "root") {// dev env
								newContent = newContent.replace("https://simply.js.org/simply.min.js", "//root/simply/simply.min.js");
							}
							blobs[file["filename"]] = {
								filename: file["filename"],
								blobUrl: blobUrl,
								content: newContent
							};
						}
					}
				}
				var runInResult = "<script>function " + component.methods.runInResult.toString() + "runInResult();<\/script>";
				var base = "<head><base href='" + document.location.href + "'>";

				blobs["index.html"].content = blobs["index.html"].content.replace("<head>", base) + runInResult;
				dom.querySelector("iframe").setAttribute("src", "about:blank");
				//dom.querySelector("iframe#result").setAttribute("srcdoc", "");

				dom.querySelector("iframe#result").addEventListener("load", function bas() {
					dom.querySelector("iframe#result").removeEventListener("load", bas);
					dom.querySelector("iframe").removeAttribute("src");
					data.urlHistory = [data.urlHistory[0]];
					data.url = data.urlHistory[0];
					data.currentUrlIndex = 1;
					data.console = [];

					setTimeout(function () {
						var textArea = document.createElement('textarea');
						textArea.innerHTML = blobs["index.html"].content;
						dom.querySelector("iframe#result").contentWindow.dataContent = textArea.value;
						dom.querySelector("iframe#result").contentWindow.document.write(textArea.value);
						//dom.querySelector("iframe#result").contentWindow.document.querySelector("body").setAttribute("data-content", textArea.value);
						data.resultStatus = "loaded";
					}, 0);
				});
			},
			getFiles(filename, content) {
				// getFiles fonksiyonu recursive bir ÅŸeklilde
				// tÃ¼m dosya isimlerini iÃ§erikleriyle beraber
				// collect ediyor
				var regex = /(?<!\/\/(\s+)?)get\((\s+)?(\[)?([\s\S]*?)?(\,)?(\s+)?\]?(\s+)?\)(\;)?/gm;
				var regex2 = /(?<!\/\/(\s+)?)get\((\s+)?(\[)?([\s\S]*?)?(\,)?(\s+)?\]?(\s+)?\)(\;)?/gm;
				var cssImport = /@import\s+(\"|\')(.*)(\"|\');/gm;
				var linkCss = /<link.*href\=(\"|\')(.*)(\"|\')/gm;
				var blobs = "";
				let m;
				let mm;

				if (!component.files) {
					component.files = [];
				}

				if (!component.files[filename]) {
					component.files[filename] = {};
				}

				while ((m = cssImport.exec(content)) !== null) {
					let fn = m[2];
					if (component.editors[fn]) {
						component.files[m[2]] = {};
						component.files[m[2]].content = component.editors[m[2]].getValue();
						component.files[m[2]].filename = fn;
					}
				}

				while ((m = linkCss.exec(content)) !== null) {
					let fn = m[2];
					if (component.editors[fn]) {
						component.files[m[2]] = {};
						component.files[m[2]].content = component.editors[m[2]].getValue();
						component.files[m[2]].filename = fn;
					}
				}

				// console.log(filename);
				while ((m = regex.exec(content)) !== null) {
					// This is necessary to avoid infinite loops with zero-width matches
					if (m.index === regex.lastIndex) {
						regex.lastIndex++;
					}
					// get array ise
					if (m[3]) {
						var f = m[4].replace(/((\\n)|[\\\s\"\[\]])/g, "");
						var fns = f.split(",");
						for (let i = 0; i < fns.length; i++) {
							var fn = fns[i].replace(/\'\"/g, '');

							if (isRealFile()) { continue; }
						}
						console.log("get array ise", m[3], f, fns);
					}
					// file with custom name
					else if (m[4].indexOf(",") > -1) {
						console.log("file with custom name ", m[4], fn);
						var fn = m[4].replace(/((\\n)|[\\\s\"\[\]])/g, "").split(",")[0];
						if (isRealFile()) { continue; }
					}
					// get sadece dosya adÄ± ise
					else {
						var fn = m[4].slice(0, -1).replace(/((\\n)|[\\\s\"\[\]])/g, "");
						// console.log("get sadece dosya adÄ± ise ", fn);
						if (isRealFile()) { continue; }
					}

				}
				function isRealFile() {
					try {
						var nestedComponentContent = component.editors[fn].getValue();
						while ((mm = regex2.exec(content)) !== null) {
							var nnestedComponentContent = component.editors[fn].getValue();
							component.methods.getFiles(fn, nnestedComponentContent);
						}
					} catch (error) {
						// bu dosyayÄ± skip ediyoruz
						// real path ile Ã§ekicez
						// console.log("haydi barÄ±Ä±Ä±ÅŸ", fn);
						return true;
					}
				}

				// burdan sonra hepsini toparlayÄ±p tek seferde dÃ¶nÃ¼yor
				component.files[filename]["content"] = content;
				component.files[filename]["filename"] = filename;
				return component.files;
			},
			changeSelectedFile(event) {
				event.preventDefault();
				event.stopPropagation();
				var filename = event.currentTarget.getAttribute("filename");
				var filenameSelector = filename.replace(/\./g, "\\.");

				for (let i = 0; i < data.files.length; i++) {
					var fn = data.files[i]["filename"];
					if (filename == fn) {
						data.files[i]["selected"] = true;
					}
					else {
						data.files[i]["selected"] = false;
					}
				}

				var targetFile = dom.querySelector("#files .CodeMirror[selected=true]");
				var fileItself = dom.querySelector("#files .CodeMirror[filename='" + filenameSelector + "']");

				var mode = methods.detectCmMode(filename);
				component.editors[filename].setOption("mode", mode);

				targetFile.setAttribute("selected", false);
				fileItself.setAttribute("selected", true);

				component.editors[filename].refresh();
				component.editors[filename].focus();

			},
			runInResult() {
				simply.setupInlineComps(document);
				window.addEventListener('message', (event) => {
					if (event.data.action == "consoleEnter") {
						eval("console.log(" + JSON.stringify(event.data.code) + ");//@ sourceURL=console");

						if (event.data.code.indexOf("console") !== 0) {
							try {
								if (JSON.parse(event.data.code)) {
									var type = "";
									if (Array.isArray(JSON.parse(event.data.code))) {
										var type = "Array: ";
									}
									else if (typeof JSON.parse(event.data.code) == "object") {
										var type = "Object: "
									}

									eval("console.log('" + type + "' + " + JSON.stringify(event.data.code) + ");//@ sourceURL=console");
								}
							} catch (error) {
								if (typeof eval(event.data.code) == "object") {
									var type = eval(event.data.code) instanceof Element ? "[HTMLElement]" : "[Object]";

									eval("console.log('" + type + "');//@ sourceURL=console");
								}
								else {
									console.log(event.data.code);
									eval("console.log(" + event.data.code + ");//@ sourceURL=console");
								}
							}
						}
						else {
							eval(event.data.code + "//@ sourceURL=console");
						}
					}
					else if (event.data.action = "go") {
						console.log(`Received message from parent: ${event.data.url}`);
						window.frameElement.contentWindow.simply.Router.go(event.data.url);
					}
				});

				window.addEventListener('popstate', function (event) {
					window.parent.postMessage({
						action: "urlChange",
						url: "/" + router.location.pathname
					}, event);
				});

				(function (w) {
					"use strict";

					var A, F, O, consoleMethods, fixConsoleMethod, consoleOn,
						allHandlers, methodObj;

					A = [];
					F = function () { return; };
					O = {};

					// All possible standard methods to provide an interface for
					consoleMethods = [
						"assert", "clear", "count", "debug",
						"dir", "dirxml", "error", "exception",
						"group", "groupCollapsed", "groupEnd",
						"info", "log", "profile", "profileEnd",
						"table", "time", "timeEnd", "timeStamp",
						"trace", "warn"
					];

					// Holds handlers to be executed for every method
					allHandlers = [];

					// Holds handlers per method
					methodObj = {};

					// Overrides the existing console methods, to call any stored handlers first
					fixConsoleMethod = (function () {
						var func, empty;

						empty = function () {
							return F;
						};

						if (w.console) {
							// If `console` is even available
							func = function (methodName) {
								var old;
								if (methodName in console && (old = console[methodName])) {
									// Checks to see if `methodName` is defined on `console` and has valid function to execute
									// (and stores the old handler)
									// This is important so that undefined methods aren't filled in
									console[methodName] = function () {
										// Overwrites current console method with this function
										var args, argsForAll, i, j;
										// Copy all arguments passed to handler
										args = A.slice.call(arguments, 0);
										for (i = 0, j = methodObj[methodName].handlers.length; i < j; i++) {
											// Loop over all stored handlers for this specific method and call them
											F.apply.call(methodObj[methodName].handlers[i], console, args);
										}
										for (i = 0, j = allHandlers.length; i < j; i++) {
											// Loop over all stored handlers for ALL events and call them
											argsForAll = [methodName];
											A.push.apply(argsForAll, args);


											var file = new Error().stack.split("\n")[2].split("(");

											if (typeof file[1] == undefined) {
												file = file[1].split(":");
												console.file = file[0];
												console.line = file[1];
												console.char = file[2].slice(0, -1);
											}



											F.apply.call(allHandlers[i], console, argsForAll);
										}
										// Calls old
										F.apply.call(old, console, args);
									};

								}
								return console[methodName] || empty;
							};
						} else {
							func = empty;
						}

						return func;
					}());

					// Loop through all standard console methods and add a wrapper function that calls stored handlers
					(function () {
						var i, j, cur;
						for (i = 0, j = consoleMethods.length; i < j; i++) {
							// Loop through all valid console methods
							cur = consoleMethods[i];
							methodObj[cur] = {
								handlers: []
							};
							fixConsoleMethod(cur);
						}
					}());

					// Main handler exposed
					consoleOn = function (methodName, callback) {
						var key, cur;
						if (O.toString.call(methodName) === "[object Object]") {
							// Object literal provided as first argument
							for (key in methodName) {
								// Loop through all keys in object literal
								cur = methodName[key];
								if (key === "all") {
									// If targeting all events
									allHandlers.push(cur);
								} else if (key in methodObj) {
									// If targeting specific valid event
									methodObj[key].handlers.push(cur);
								}
							}
						} else if (typeof methodName === "function") {
							// Function provided as first argument
							allHandlers.push(methodName);
						} else if (methodName in methodObj) {
							// Valid String event provided
							methodObj[methodName].handlers.push(callback);
						}
					};

					// Actually expose an interface
					w.ConsoleListener = {
						on: consoleOn
					};
				}(this));

				ConsoleListener.on(function (methodName, message) {
					try {
						if (typeof eval(message) == "object") {
							if (message instanceof ShadowRoot) {
								message = "[ShadowRoot]"
							}
							else if (message instanceof Window) {
								message = "[Window]"
							}
							else if (message instanceof Document) {
								message = "[Document]"
							}
							else if (eval(message) instanceof Element) {
								message = "[HTMLElement] " + message.tagName
							}
							else {
								// normal obj ise
								try {
									message = JSON.stringify(message);
								} catch (e) {
									// circular obj ise
									const getCircularReplacer = () => {
										const seen = new WeakSet();
										return (key, value) => {
											if (typeof value === "object" && value !== null) {
												if (seen.has(value)) {
													return;
												}
												seen.add(value);
											}
											if (key !== "__o_" && key !== "__c_" && key !== "__p_" && key !== "__r_") {
												return value;
											}
										};
									};
									message = JSON.stringify(message, getCircularReplacer());
								}
							}
						}
					} catch (error) { }

					self = this;
					window.parent.postMessage({
						action: "console",
						method: methodName,
						message: message,
						file: self.file,
						line: self.line,
						char: self.char
					}, event);
				});

				window.onerror = function (error, file, line, char) {
					if (file !== "console") {
						var file = file;
						var line = line;
						var char = char;
					}

					window.parent.postMessage({
						action: "console",
						method: "error",
						message: error,
						file,
						line,
						char
					}, event);
				};
			},
			changeURL(event) {
				var result = dom.querySelector("iframe#result").contentWindow;
				if (event.target) {
					var url = event.target.value;
					event.target.blur();
				}
				else {
					var url = event;
				}
				result.postMessage({
					action: "go",
					url: document.location.pathname + url.replace(/^\//, '')
				});
			},
			goBack(event) {
				data.currentUrlIndex -= 1;
				var url = data.urlHistory[data.currentUrlIndex - 1];
				component.methods.changeURL(url);
			},
			goNext(event) {
				data.currentUrlIndex += 1;
				var url = data.urlHistory[data.currentUrlIndex - 1];
				component.methods.changeURL(url);
			},
			sendJStoResult(event) {
				if (event.which == 13) {
					var result = dom.querySelector("iframe#result").contentWindow;
					var code = event.target.value;
					event.target.value = "";
					result.postMessage({ action: "consoleEnter", code: code });
					dom.querySelector("input[name=consoleEntry]").focus();
				}
			},
			clearConsole(e) {
				data.console = [];
			},
			resize(e) {

				var direction = e.target.className == "v-resizer" ? "v" : "h";
				if (direction == "v") {
					data.resize.x = true;
				}
				else {
					data.resize.y = true;
				}

				e.preventDefault();
				dom.addEventListener("mousemove", function (me) {
					if (!data.resize.x && !data.resize.y) {
						return;
					}
					me.preventDefault();
					var containerWidth = dom.getRootNode().host.offsetWidth;
					var containerHeight = dom.getRootNode().host.offsetHeight;

					if (data.resize.x) {
						var offsetRight = containerWidth - (me.clientX - dom.getRootNode().host.getBoundingClientRect().left);
						var birim = containerWidth / 100;
						offsetRight = 100 - (offsetRight / birim);
						data.editorWidth = offsetRight + "%";
					}
					else {
						var offsetTop = containerHeight - (me.clientY - dom.getRootNode().host.getBoundingClientRect().top);
						data.topAreaHeight = Math.abs(offsetTop) + "px";
					}
				});
				document.addEventListener("mouseup", function (e) {
					e.preventDefault();
					data.resize.x = false;
					data.resize.y = false;
				});

			},
			openFileGotoLine(filename, line, char) {
				for (let i = 0; i < data.files.length; i++) {
					const file = data.files[i];
					if (file.filename == filename) {
						file.selected = true;
					}
					else {
						file.selected = false;
					}
				}
				var filenameSelector = filename.replace(/\./g, "\\.");

				var targetFile = dom.querySelector("#files .CodeMirror[selected=true]");
				var fileItself = dom.querySelector("#files .CodeMirror[filename='" + filenameSelector + "']");

				targetFile.setAttribute("selected", false);
				fileItself.setAttribute("selected", true);

				component.editors[filename].setCursor(line - 1, char - 1);
				component.editors[filename].refresh();
				component.editors[filename].focus();
			},
			focusFilename(e) {
				console.log("focus filename");
				if (props.crud == true) {
					var selected = e.target.parentElement.parentElement.getAttribute("selected");
					if (selected == "true") {
						e.stopPropagation();
						e.target.readOnly = false;
						e.target.parentElement.parentElement.classList.add("focus");
						e.target.focus();
					}
				}
			},
			inputFilename(e) {
				var ghost = e.target.parentElement.parentElement.querySelector(".ghost-input");
				ghost.innerHTML = e.target.value;
			},
			renameFilename(e) {
				console.log("rename");
				var oldName = e.target.parentElement.parentElement.getAttribute("filename");
				var newName = e.target.value;

				if (newName == oldName) {
					e.target.blur();
				}
				else if (newName !== "" && !component.editors[newName]) {
					console.log("hem boÅŸ deÄŸil hem duplicate deÄŸil");
					for (let i = 0; i < data.files.length; i++) {
						const file = data.files[i];
						if (file.filename == oldName) {
							file.filename = newName;


							component.editors[newName] = component.editors[oldName];
							delete component.editors[oldName];
							dom.querySelector(".CodeMirror[filename='" + oldName + "']").setAttribute("filename", newName);


							if (newName.substring(newName.length - ".css".length) == ".css") {
								console.log("nurtopu gibi bir css'imiz oluyor");
								component.editors[newName].setOption("mode", "css");
								component.editors[newName].setValue(':root {\n} \n\n:host {\n}');
							}
							else if (newName.substring(newName.length - ".html".length) == ".html") {
								component.editors[newName].setOption("mode", "htmlmixed");
								component.editors[newName].setValue('<html>\n\n</html>\n\n<style>\n\t:host {\n\n\t}\n</style>\n\n<script>\n\tclass simply \{\n\n\t}\n<\/script>');
							}
							else if (newName.substring(newName.length - ".js".length) == ".js") {
								component.editors[newName].setOption("mode", "javascript");
								component.editors[newName].setValue('console.log("hello!");');
							}
							console.log(component.editors[newName]);
						}
					}
					component.methods.renderResult();
				}
				else {
					console.log("boÅŸ ya da duplicate");
					if (oldName !== e.target.focus()) {
						e.target.focus();
						return false;
					}
				}
			},
			renameIfEnter(e) {
				var keycode = (e.keyCode ? e.keyCode : e.which);
				if (keycode === 13 || e.key === 'Enter') {
					methods.renameFilename(e);
				}
			},
			blurFilename(e) {
				var selected = e.target.parentElement.parentElement.getAttribute("selected");

				if (selected == "true") {
					e.stopPropagation();
					e.target.parentElement.parentElement.classList.remove("focus");
				}
			},
			deleteFile(e) {
				e.stopPropagation();
				var filename = e.target.parentElement.getAttribute("filename");

				if (confirm('Delete ' + filename + '?')) {
					component.editors[filename].setOption("mode", "text/x-csrc");
					component.editors[filename].getWrapperElement().remove();
					delete component.editors[filename];
					delete component.files[filename];

					for (let i = 0; i < data.files.length; i++) {
						const file = data.files[i];
						if (file.filename == filename) {
							console.log(data.files, i);
							delete data.files[i];
							data.files = data.files.filter(Boolean);
							filename = data.files[i - 1].filename;
							var filenameSelector = filename.replace(/\./g, "\\.");
							var targetFile = dom.querySelector("#files .CodeMirror[selected=true]");
							if (!targetFile) {
								data.files[i - 1].selected = true;
								var fileItself = dom.querySelector("#files .CodeMirror[filename='" + filenameSelector + "']");
								fileItself.setAttribute("selected", true);
							}
							break;
						}
					}
					component.methods.renderResult();
					return false;
				} else {
					return false;
				}
			},
			addFile() {
				var i = 1;
				var filename = "component-" + i;
				console.log(component.editors);
				while (component.editors["component-" + i + ".html"]) {
					i = i + 1;
				}
				filename = "component-" + i + ".html";
				for (let i = 0; i < data.files.length; i++) {
					const file = data.files[i];
					file.selected = false;
				}
				data.files.push({ "filename": filename, "selected": true });

				var fileTabs = dom.querySelector("#file-tabs");
				fileTabs.scrollLeft = fileTabs.scrollWidth;

				var template = "<html>\n\n</html>\n\n<style>\n\t:host {\n\n\t}\n</style>\n\n<script>\n\tclass simply \{\n\n\t}\n<\/script>";
				var target = dom.querySelector("ul#files");
				component.methods.createNewCodemirror(filename, true, target, template);

				dom.querySelector("#files .CodeMirror[selected=true]").setAttribute("selected", false);
				//component.editors[filename].setCursor({ line: 1, ch: 0 });
				component.files[filename] = {
					filename: filename,
					content: template
				}
				setTimeout(() => {
					var filenameInput = dom.querySelector("li[filename=" + filename.replace(/\./g, "\\.") + "] input");

					filenameInput.click();
					filenameInput.setSelectionRange(0, filenameInput.value.length);
				}, 0);

				console.log(component.files);
			},
			detectCmMode(filename) {
				var mode;
				if (filename.indexOf(".css") > -1) {
					mode = "css";
				}
				else if (filename.indexOf(".js") > -1) {
					mode = "javascript";
				}
				else {
					mode = "htmlmixed";
				}
				return mode;
			},
			createNewCodemirror(filename, selected, targetEl, text) {
				var autofocus = props.focus ? true : false;
				var mode = methods.detectCmMode(filename);
				component.editors[filename] = CodeMirror(function (node) {
					node.setAttribute("filename", filename);
					node.setAttribute("selected", selected);
					targetEl.appendChild(node, targetEl);
				}, {
					value: text,
					autoRefresh: { delay: 0 },
					lineNumbers: true,
					gutter: true,
					tabSize: 2,
					smartIndent: true,
					autofocus: autofocus,
					mode: mode,
					theme: 'default', // ambiance, ayu-mirage, cobalt, dracula, material, rubyblue, nord
					styleActiveLine: true,
					lineWrapping: true,
					foldGutter: true,
					gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"]
				});
				var render;
				component.editors[filename].on("changes", function (a, b, c, d) {
					data.resultStatus = "loading";
					try {
						clearTimeout(render);
					} catch (error) { }

					render = setTimeout(function () {
						component.methods.renderResult();

					}, 1000); // How long do you want the delay to be (in milliseconds)?
				});

				var currentHandle = null, currentLine;
				component.editors[filename].on("cursorActivity", highlight);
				component.editors[filename].on("focus", highlight);

				function highlight(cm) {
					var line = cm.getCursor().line;
					var handle = cm.getLineHandle(line);

					if (currentHandle) {
						cm.removeLineClass(currentHandle, "wrap", "activeline");
					}
					currentHandle = handle;
					currentLine = line;
					cm.addLineClass(currentHandle, null, "activeline");
				}
			},
			fullscreenToggle() {
				if (dom.getRootNode().host.className.indexOf("fullscreen") > -1) {
					dom.getRootNode().host.classList.remove("fullscreen");
				}
				else {
					dom.getRootNode().host.classList.add("fullscreen");
				}

			},
			titleFocus(e) {
				if (props.crud) {
					e.stopPropagation();
					e.target.readOnly = false;
					e.target.focus();
				}

			},
			titleInput(e) {
				var ghost = e.target.parentElement.querySelector(".ghost-input");
				ghost.innerHTML = e.target.value;
			},
			format(e) {
				// https://prettier.io/docs/en/browser.html
				// https://github.com/beautify-web/js-beautify
				// https://stackoverflow.com/questions/25109809/codemirror-auto-format-after-setvalue
				// https://stackoverflow.com/questions/25561913/anyone-know-what-happened-to-the-autoformat-feature-in-codemirror

				CodeMirror.extendMode("css", {
					commentStart: "/*",
					commentEnd: "*/",
					newlineAfterToken: function (type, content) {
						return /^[;{}]$/.test(content);
					}
				});

				CodeMirror.extendMode("javascript", {
					commentStart: "/*",
					commentEnd: "*/",
					// FIXME semicolons inside of for
					newlineAfterToken: function (type, content, textAfter, state) {
						if (this.jsonMode) {
							return /^[\[,{]$/.test(content) || /^}/.test(textAfter);
						} else {
							if (content == ";" && state.lexical && state.lexical.type == ")") return false;
							return /^[;{}]$/.test(content) && !/^;/.test(textAfter);
						}
					}
				});

				CodeMirror.extendMode("xml", {
					commentStart: "<!--",
					commentEnd: "-->",
					newlineAfterToken: function (type, content, textAfter) {
						return type == "tag" && />$/.test(content) || /^</.test(textAfter);
					}
				});

				component.data.files.forEach(element => {
					if (element.selected) {
						var editor = component.editors[element.filename];
						CodeMirror.commands["selectAll"](editor);

						function getSelectedRange() {
							return { from: editor.getCursor(true), to: editor.getCursor(false) };
						}

						var from = editor.getCursor(true);
						var to = editor.getCursor(false);
						var cm = editor;
						var outer = cm.getMode(), text = cm.getRange(getSelectedRange().from, to).split("\n");
						var state = CodeMirror.copyState(outer, cm.getTokenAt(from).state);
						var tabSize = cm.getOption("tabSize");

						var out = "", lines = 0, atSol = from.ch == 0;
						function newline() {
							out += "\n";
							atSol = true;
							++lines;
						}

						for (var i = 0; i < text.length; ++i) {
							var stream = new CodeMirror.StringStream(text[i], tabSize);
							while (!stream.eol()) {
								var inner = CodeMirror.innerMode(outer, state);
								var style = outer.token(stream, state), cur = stream.current();
								stream.start = stream.pos;
								if (!atSol || /\S/.test(cur)) {
									out += cur;
									atSol = false;
								}
								if (!atSol && inner.mode.newlineAfterToken &&
									inner.mode.newlineAfterToken(style, cur, stream.string.slice(stream.pos) || text[i + 1] || "", inner.state))
									newline();
							}
							if (!stream.pos && outer.blankLine) outer.blankLine(state);
							if (!atSol) newline();
						}

						cm.operation(function () {
							cm.replaceRange(out, from, to);
							for (var cur = from.line + 1, end = from.line + lines; cur <= end; ++cur)
								cm.indentLine(cur, "smart");
							cm.setSelection(from, cm.getCursor(false));
						});



					}
				});

			},
			titleRename(e) {
				if (e.target.value.length !== 0) {
					props.title = e.target.value;
					e.target.blur();
				}
				else {
					e.target.focus();
				}

				console.log("yeah");
			},
			download() {
				var license = 'MIT License \n\
Copyright (c) '+ new Date().getFullYear() + ' simply.js \n\
\n\
Permission is hereby granted, free of charge, to any person obtaining a copy\n\
of this software and associated documentation files (the "Software"), to deal\n\
in the Software without restriction, including without limitation the rights\n\
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\
copies of the Software, and to permit persons to whom the Software is\n\
furnished to do so, subject to the following conditions:\n\
\n\
The above copyright notice and this permission notice shall be included in all\n\
copies or substantial portions of the Software.\n\
\n\
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\
SOFTWARE.';
				var zip = new JSZip();
				//zip.file("Hello.txt", "Hello World\n");
				//var img = zip.folder("images");
				//img.file("smile.gif", imgData, { base64: true });
				for (let i = 0; i < data.files.length; i++) {
					var filename = data.files[i].filename;
					var editor = component.editors[filename];
					var content = editor.getValue();
					zip.file(filename, content);
					zip.file("LICENSE", license)
					zip.file("README.md", "Welcome to simply.js");
				}
				zip.generateAsync({ type: "blob" }).then(function (content) {
					// see FileSaver.js
					saveAs(content, props.title + ".zip");
				});
			},
			save() {
				console.log("save", component.editors);
				var project = {
					title: props.title,
					files: []
				};
				for (var i = 0; i < data.files.length; i++) {
					var file = data.files[i];
					var filename = file.filename;
					var content = component.editors[filename].getValue();
					var selected = file.selected
					project.files.push({ filename, content, selected });
				}

				var d = new FormData();
				// https://developer.mozilla.org/en-US/docs/Glossary/Base64
				var url = btoa(unescape(encodeURIComponent(JSON.stringify(project))));

				d.append("longurl", url);
				var xhr = new XMLHttpRequest();
				xhr.withCredentials = true;
				xhr.addEventListener("readystatechange", function () {
					if (this.readyState === 4) {
						var id = this.responseText;
						if (document.location.hash.indexOf("?") > -1) {
							var hash = document.location.hash.split("?")[0];
						}
						else {
							var hash = document.location.hash;
						}

						window.history.pushState('', '', document.location.origin + document.location.pathname + hash + "?" + id);
					}
				});

				xhr.open("POST", data.URLShortening.short);
				xhr.send(d);
			},
			init() {

				var slot = dom.querySelector('slot[name=files]');
				component.editors = [];

				if ((location.hash.length > 1 && location.hash.indexOf("?") > -1) || props.id) {

					if (location.hash.split("?")[1] !== undefined) {
						var id = location.hash.split("?")[1];
					}
					else if (props.id) {
						var id = props.id;
					}

					var xhr = new XMLHttpRequest();
					xhr.withCredentials = true;
					xhr.open("GET", data.URLShortening.redirect + id, true);
					xhr.send();
					xhr.addEventListener("readystatechange", function () {
						if (this.readyState === 4) {
							var project = JSON.parse(decodeURIComponent(escape(atob(this.responseText))));

							var targetEl = dom.querySelector("ul#files");

							for (var i = 0; i < project.files.length; i++) {
								var file = project.files[i];
								data.files.push({
									filename: file.filename,
									selected: file.selected
								});
								component.methods.createNewCodemirror(file.filename, file.selected, targetEl, file.content);
							}
							props.title = project.title;

							component.methods.renderResult();
						}
					});
				}

				else if (slot.assignedNodes()[0]) {
					var files = slot.assignedNodes()[0].querySelectorAll("textarea");
					for (let index = 0; index < files.length; index++) {
						var fileEl = files[index];
						var filename = fileEl.getAttribute("filename");
						var fileContent = fileEl.value;
						var isFileSelected = fileEl.hasAttribute("selected");
						data.files.push({
							filename: filename,
							selected: isFileSelected
						});
					}

					for (var index = 0; index < files.length; index++) {
						var textarea = files[index];
						var filename = files[index].getAttribute("filename");
						var selected = files[index].hasAttribute("selected");
						var targetEl = dom.querySelector("ul#files");

						// remove unnecessary indents
						var indent = textarea.value.split('\n').join('').match(/^\s*/)[0].length;
						var text = textarea.value.trim();
						var a = new RegExp("^\ {" + indent + "}", "gm");
						text = text.replace(a, "");

						component.methods.createNewCodemirror(filename, selected, targetEl, text);
					}
					component.methods.renderResult();
				}

				var cmInitCheck = setInterval(() => {
					var px = 0;
					try {
						var px = parseInt(dom.querySelector(".CodeMirror[selected=true] > div:first-child").style.left.replace("px", ""));
					} catch (error) { }

					if (px > 100) {
						component.editors["index.html"].refresh();
					}
					else {
						clearInterval(cmInitCheck);
					}
				}, 10);
			}
		}
		lifecycle = {
			afterFirstRender() {
				window.onerror = function (error, file, line, char) {
					data.console = [];
					data.console.push({
						method: "error",
						message: error
					});
				};
				// listen messages from child
				window.addEventListener('message', (event) => {
					if (event.data.action == "urlChange") {
						data.url = event.data.url.replace(document.location.pathname, "");
						dom.querySelector("#url").value = data.url;
						
						if (data.url !== data.urlHistory[data.currentUrlIndex - 1]) {
							data.urlHistory = data.urlHistory.slice(0, data.currentUrlIndex);
							data.urlHistory.push(data.url);
							data.currentUrlIndex += 1;
						};
					}
					else if (event.data.action == "console") {
						if (component.editors[event.data.file]) {
							var file = event.data.file;
							var line = event.data.line;
							var char = event.data.char;
						}
						data.console.push({
							method: event.data.method,
							message: event.data.message,
							file,
							line,
							char
						});
						var messages = dom.querySelector("#console .messages");
						if (messages) {
							messages.scrollTop = messages.scrollHeight;
						}
					}
					else if (event.data.action == "routerOn") {
						props.addressbar = true;
					}					
				});
				loadJS("https://cdn.jsdelivr.net/combine/npm/codemirror@5.62.0/lib/codemirror.min.js,npm/codemirror@5.62.0/mode/javascript/javascript.min.js,npm/codemirror@5.62.0/mode/css/css.min.js,npm/codemirror@5.62.0/mode/xml/xml.min.js,npm/codemirror@5.62.0/mode/htmlmixed/htmlmixed.min.js,npm/codemirror@5.62.0/addon/fold/foldcode.js,npm/codemirror@5.62.0/addon/fold/foldgutter.js,npm/codemirror@5.62.0/addon/fold/xml-fold.js,npm/codemirror@5.62.0/addon/fold/brace-fold.js,npm/codemirror@5.62.0/addon/fold/comment-fold.js,npm/codemirror@5.62.0/addon/fold/indent-fold.js,npm/jszip@3.1.5/dist/jszip.min.js,npm/filesaver.js@1.3.4/FileSaver.min.js", function (src, cb) {
					methods.init();
				}, "CodeMirror");
			},

		}
		watch(name, value, old, parents) { }
	}
</script>