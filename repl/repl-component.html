<template>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/codemirror@5.62.0/lib/codemirror.min.css" />
  <div id="topArea">
    <div id="editor">
      <ul id="file-tabs">
        <each data.files as file>
          <li filename="{file.filename}" selected="{ file.selected }" onclick="changeSelectedFile(event)">
            {file.filename}
          </li>
        </each>
        <li class="add" onclick="addFile()">+</li>
      </ul>

      <ul id="files" passive>
        <slot name="files"></slot>
      </ul>
    </div>
    <div class="v-resizer" onmousedown="resize(event)"></div>
    <div id="result">
      <div id="result-header">
        Result
      </div>
      <div id="addressbar">
        <!-- {data.urlHistory.length} - {data.currentUrlIndex} -->
        <button {(data.currentUrlIndex < 2) ? "disabled" : "" } onclick="goBack(event);"></button>
        <button {(data.currentUrlIndex> data.urlHistory.length - 1) ? "disabled" : ""}
          onclick="goNext(event);"></button>
        <input type="text" value="{data.url}" id="url" onchange="changeURL(event)">
      </div>
      <iframe id="result" name="result" {(data.resize.x || data.resize.y) ? "resizing" : "" }></iframe>
    </div>
  </div>
  <div class="h-resizer"></div>
  <div id="console">
    <label>CONSOLE <a onclick="clearConsole(event)">Clear</a></label>
    <ul class="messages">
      <each data.console as entry>
        <li class="{entry.method}">{entry.message} <if entry.file>(<span class="debugLink"
              onclick="openFileGotoLine('{entry.file}', '{entry.line}','{entry.char}')">{entry.file}:{entry.line}:{entry.char}</span>)
          </if>
        </li>
      </each>
    </ul>
    <input placeholder=">_" name="consoleEntry" onkeyup="sendJStoResult(event)">
  </div>
</template>

<style>
  :host {
    display: flex;
    width: 960px;
    height: 550px;
    border: 2px solid #dddddd;
    font-family: Arial, Helvetica, sans-serif;
    flex-direction: column;
  }

  slot[name=files] {
    display: none;
  }

  #topArea {
    display: flex;
    height: 80%;
    height: calc(100% - 120px);
  }

  #editor {
    display: flex;
    flex-direction: column;
    width: "{data.editorWidth}";
    min-width: 30%;
    max-width: 70%;
  }

  #result {
    display: flex;
    flex-direction: column;
    border-left: 2px solid #dddddd;
    box-sizing: border-box;
    flex: 1;
  }

  .v-resizer {
    cursor: ew-resize;
    width: 1px;
    position: relative;
  }

  .v-resizer:after {
    content: "";
    display: block;
    height: 100%;
    width: 8px;
    position: absolute;
    z-index: 10;
  }

  .h-resizer {
    cursor: ns-resize;
    height: 1px;
    width: 100%;
    position: relative;
  }

  .h-resizer:after {
    content: "";
    display: block;
    width: 100%;
    height: 8px;
    position: absolute;
    left: -2px;
    z-index: 10;
  }

  #console {
    border-top: 2px solid #dddddd;
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: overlay;
  }

  #console .messages {
    flex: 1;
    list-style: none;
    font-family: monospace;
    padding: 0;
    margin: 0px;
  }

  #console .messages li {
    border-color: #d4d4d4;
    border-style: solid;
    border-width: 1px 0px;
    padding: 3px 10px;
    margin-top: -1px;
    font-size: 12px;
  }

  #console .messages li.error {
    border-color: #fed6d7;
    background-color: #fff0f0;
    color: #fc0d1b;
  }

  #console .messages li.warn {
    border-color: #f3e5a7;
    background-color: #fffbe6;
    color: #5c3c08;
  }

  #console label {
    background-color: #f1f1f1;
    width: 100%;
    display: block;
    font-family: monospace;
    font-size: 14px;
    padding: 5px 10px;
    box-sizing: border-box;
    color: #666666;
    position: sticky;
    top: 0px;
  }

  input[name=consoleEntry] {
    font-family: monospace;
    border: none;
    padding: 5px 10px;
    font-size: 12px;
    outline: none;
  }

  #file-tabs {
    /* border-bottom: 2px solid #dddddd; */
    line-height: 35px;
    overflow: overlay;
    -webkit-background-clip: text;
    background-clip: text;
    background-color: rgba(0, 0, 0, 0);
    transition: background-color .8s;
    height: 35px;
  }

  .CodeMirror-vscrollbar,
  .CodeMirror-hscrollbar {
    -webkit-background-clip: text;
    background-clip: text;
    background-color: rgba(0, 0, 0, 0);
    transition: background-color .8s;
  }

  #file-tabs::-webkit-scrollbar,
  .CodeMirror-hscrollbar::-webkit-scrollbar {
    width: 5px;
    height: 5px;
  }

  .CodeMirror-vscrollbar::-webkit-scrollbar {
    width: 10px;
  }

  .CodeMirror-hscrollbar::-webkit-scrollbar {
    height: 10px;
  }

  #file-tabs::-webkit-scrollbar-track,
  .CodeMirror-vscrollbar::-webkit-scrollbar-track,
  .CodeMirror-hscrollbar::-webkit-scrollbar-track {
    background-color: transparent;

  }

  #file-tabs::-webkit-scrollbar-thumb,
  .CodeMirror-vscrollbar::-webkit-scrollbar-thumb,
  .CodeMirror-hscrollbar::-webkit-scrollbar-thumb {
    background-color: rgb(206, 206, 206);
  }


  #file-tabs::-webkit-scrollbar-thumb,
  .CodeMirror-vscrollbar::-webkit-scrollbar-thumb,
  .CodeMirror-hscrollbar::-webkit-scrollbar-thumb {
    background-color: inherit;
  }

  #file-tabs:hover,
  .CodeMirror:hover .CodeMirror-vscrollbar,
  .CodeMirror:hover .CodeMirror-hscrollbar {
    background-color: rgb(206, 206, 206);
  }

  #file-tabs li {
    position: relative;
    cursor: pointer;
    padding: 0px 15px;
    font-size: 14px;
    color: #888;
    white-space: nowrap;
    background-color: #f1f1f1;
  }

  #file-tabs .add {
    font-size: 22px;
    padding: 0px 10px 0px 5px;
  }

  #file-tabs li[selected=true] {
    cursor: default;
    pointer-events: none;
    background-color: white;
    color: #292;
  }

  /*
  #file-tabs li[selected=true]::after {
    content: "";
    position: absolute;
    width: 100%;
    height: 3px;
    background-color: #292;
    bottom: 0px;
    left: 0px;
  }
  */

  #result-header {
    border-bottom: 2px solid #dddddd;
    line-height: 35px;
    font-size: 14px;
    padding: 0px 15px;
  }

  #file-tabs,
  #files {
    display: flex;
    list-style: none;
    padding: 0px;
    margin: 0px;
  }

  #files {
    flex: 1;
    flex-direction: column;
    height: 0px;
  }

  .CodeMirror {
    height: 100%;
    width: 100%;
    display: none;
    line-height: 20px;
  }

  .CodeMirror[selected=true] {
    display: block;
  }

  #files textarea,
  iframe#result {
    width: 100%;
    height: 100%;
    border: none;
  }

  iframe#result[resizing] {
    pointer-events: none;
  }

  #addressbar {
    display: flex;
    align-items: center;
  }

  #addressbar button {
    background-size: contain;
    background-repeat: no-repeat;
    width: 17px;
    height: 17px;
    border: none;
    cursor: pointer;
  }

  #addressbar button:disabled {
    opacity: .4;
    cursor: default;
  }

  #addressbar button:nth-child(1) {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'%3E%3Ctitle%3Eicon-arrow-left%3C/title%3E%3Cpolyline points='20.6 8 5.62 24.1 20.6 40.2' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/polyline%3E%3Cline x1='7.53' y1='24.1' x2='42.33' y2='24.1' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/line%3E%3C/svg%3E");
    margin-right: 10px;
  }

  #addressbar button:nth-child(2) {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'%3E%3Ctitle%3Eicon-arrow-right%3C/title%3E%3Cpolyline points='27.35 40.2 42.33 24.1 27.35 8' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/polyline%3E%3Cline x1='40.42' y1='24.1' x2='5.62' y2='24.1' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/line%3E%3C/svg%3E");
  }

  div#addressbar {
    background-color: #f2f3f7;
    border-bottom: 1px solid #ced0dd;
    padding: 10px 10px;
  }

  input#url {
    flex: 1;
    border-radius: 3px;
    outline: none;
    box-shadow: none;
    border: 1px solid #ced0dd;
    padding: 0px 10px;
    line-height: 26px;
    font-size: 14px;
    margin-left: 10px;
    transition: all ease-in .1s;
  }

  input#url:focus {
    border: 1px solid #9ec5ef;
    box-shadow: 0 2px 8px 0 rgb(0 0 0 / 8%);
  }

  .debugLink {
    color: black;
    text-decoration: underline;
    cursor: pointer;
  }

  .activeline {
    position: relative;
    background-color: rgba(0, 0, 0, .04);
  }
</style>

<script>
  class {
    data = {
      files: [],
      url: "/",
      urlHistory: [
        "/"
      ],
      currentUrlIndex: 1,
      console: [],
      resize: {
        x: false,
        y: false
      },
      editorWidth: "65%"
    }
    methods = {
      renderResult() {
        var indexContent = component.editors["index.html"].getValue();
        var files = component.methods.rewriteGet("index.html", indexContent);
        var blobs = [];

        for (let index = 0; index < Object.keys(files).length; index++) {
          var file = files[Object.keys(files).reverse()[index]];

          for (const filename in file) {
            if (blobs[filename] == undefined) {
              var newContent = file["content"];
              var m;
              var regex = /(?<!\/\/(\s+)?)get\((\[)?([\s\S]*?)?(.*)\)(\;)?/gm;

              while ((m = regex.exec(file["content"])) !== null) {
                // This is necessary to avoid infinite loops with zero-width matches
                if (m.index === regex.lastIndex) {
                  regex.lastIndex++;
                }

                if (m[3].indexOf(",") > -1) { // multi
                  var filenames = m[3].replace(/((\\n)|[\\\s\"\[\]])/g, "");
                  var filenames = filenames.split(",");
                  var get = m[0];
                  var newGet = "";
                  for (let i = 0; i < filenames.length; i++) {
                    var fn = filenames[i].replace(/\'\"/g, '');;
                    newGet += "get('" + blobs[fn].blobUrl + "', '" + fn + "');";
                  }
                  newContent = newContent.replace(get, newGet);
                }
                else {
                  var fn = m[4].slice(0, -1);
                  var get = m[0];
                  var newGet = "get('" + blobs[fn].blobUrl + "', '" + fn + "');";
                  newContent = newContent.replace(get, newGet);
                }
              }

              var blob = new Blob([newContent], { type: "text/html; charset=utf-8" });
              var blobUrl = URL.createObjectURL(blob);
              blobs[file["filename"]] = {
                filename: file["filename"],
                blobUrl: blobUrl,
                content: newContent
              };
            }
          }
        }
        var runInResult = "<script>function " + component.methods.runInResult.toString() + "runInResult();<\/script>";
        var base = "<head><base href=" + document.location.href + ">";
        blobs["index.html"].content = blobs["index.html"].content.replace("<head>", base) + runInResult;

        component.dom.querySelector("iframe").setAttribute("srcdoc", "");
        // component.dom.querySelector("iframe").setAttribute("src", "about:blank");

        component.dom.querySelector("iframe").addEventListener("load", function bas() {
          console.log("load");
          component.dom.querySelector("iframe").removeEventListener("load", bas);
          //component.dom.querySelector("iframe").removeAttribute("src");
          component.dom.querySelector("iframe").contentWindow.document.write(blobs["index.html"].content);
          // rever url
          data.urlHistory = [data.urlHistory[0]];
          data.url = data.urlHistory[0];
          data.currentUrlIndex = 1;
          data.console = [];
        });

      },
      rewriteGet(filename, content) {
        var regex = /(?<!\/\/(\s+)?)get\((\[)?([\s\S]*?)?(.*)\)(\;)?/gm;
        var regex2 = /(?<!\/\/(\s+)?)get\((\[)?([\s\S]*?)?(.*)\)(\;)?/gm;
        var blobs = "";
        let m;
        let mm;

        if (!component.files) {
          component.files = [];
        }

        if (!component.files[i]) {
          component.files[filename] = {};
        }

        while ((m = regex.exec(content)) !== null) {

          // This is necessary to avoid infinite loops with zero-width matches
          if (m.index === regex.lastIndex) {
            regex.lastIndex++;
          }

          if (m[3].indexOf(",") > -1) {

            var f = m[3].replace(/((\\n)|[\\\s\"\[\]])/g, "");
            var fns = f.split(",");
            for (let i = 0; i < fns.length; i++) {
              const fn = fns[i].replace(/\'\"/g, '');
              var nestedComponentContent = component.editors[fn].getValue();

              while ((mm = regex2.exec(content)) !== null) {
                var nnestedComponentContent = component.editors[fn].getValue();;
                component.methods.rewriteGet(fn, nnestedComponentContent);
              }
            }
          }

          else {
            var fn = m[4].slice(0, -1);
            var nestedComponentContent = component.editors[fn].getValue();

            while ((mm = regex2.exec(content)) !== null) {
              var nnestedComponentContent = component.editors[fn].getValue();;
              component.methods.rewriteGet(fn, nnestedComponentContent);
            }
          }
        }

        component.files[filename]["content"] = content;
        component.files[filename]["filename"] = filename;
        return component.files;
      },
      changeSelectedFile(event) {
        var filename = event.target.getAttribute("filename");
        var filenameSelector = filename.replace(/\./g, "\\.");

        for (let i = 0; i < data.files.length; i++) {
          var fn = data.files[i]["filename"];
          if (filename == fn) {
            data.files[i]["selected"] = true;
          }
          else {
            data.files[i]["selected"] = false;
          }
        }

        var targetFile = component.dom.querySelector("#files .CodeMirror[selected=true]");
        var fileItself = component.dom.querySelector("#files .CodeMirror[filename='" + filenameSelector + "']");

        targetFile.setAttribute("selected", false);
        fileItself.setAttribute("selected", true);

        component.editors[filename].refresh();
      },
      addFile() {
        console.log("ekleriz sorun deÄŸil");
      },
      runInResult() {
/*
    cycle.js
    2021-05-31

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    This code should be minified before deployment.
    See https://www.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.
*/

// The file uses the WeakMap feature of ES6.

/*jslint eval */

/*property
    $ref, decycle, forEach, get, indexOf, isArray, keys, length, push,
    retrocycle, set, stringify, test
*/

if (typeof JSON.decycle !== "function") {
    JSON.decycle = function decycle(object, replacer) {
        "use strict";

// Make a deep copy of an object or array, assuring that there is at most
// one instance of each object or array in the resulting structure. The
// duplicate references (which might be forming cycles) are replaced with
// an object of the form

//      {"$ref": PATH}

// where the PATH is a JSONPath string that locates the first occurance.

// So,

//      var a = [];
//      a[0] = a;
//      return JSON.stringify(JSON.decycle(a));

// produces the string '[{"$ref":"$"}]'.

// If a replacer function is provided, then it will be called for each value.
// A replacer function receives a value and returns a replacement value.

// JSONPath is used to locate the unique object. $ indicates the top level of
// the object or array. [NUMBER] or [STRING] indicates a child element or
// property.

        var objects = new WeakMap();     // object to path mappings

        return (function derez(value, path) {

// The derez function recurses through the object, producing the deep copy.

            var old_path;   // The path of an earlier occurance of value
            var nu;         // The new object or array

// If a replacer function was provided, then call it to get a replacement value.

            if (replacer !== undefined) {
                value = replacer(value);
            }

// typeof null === "object", so go on if this value is really an object but not
// one of the weird builtin objects.

            if (
                typeof value === "object"
                && value !== null
                && !(value instanceof Boolean)
                && !(value instanceof Date)
                && !(value instanceof Number)
                && !(value instanceof RegExp)
                && !(value instanceof String)
            ) {

// If the value is an object or array, look to see if we have already
// encountered it. If so, return a {"$ref":PATH} object. This uses an
// ES6 WeakMap.

                old_path = objects.get(value);
                if (old_path !== undefined) {
                    return {$ref: old_path};
                }

// Otherwise, accumulate the unique value and its path.

                objects.set(value, path);

// If it is an array, replicate the array.

                if (Array.isArray(value)) {
                    nu = [];
                    value.forEach(function (element, i) {
                        nu[i] = derez(element, path + "[" + i + "]");
                    });
                } else {

// If it is an object, replicate the object.

                    nu = {};
                    Object.keys(value).forEach(function (name) {
                        nu[name] = derez(
                            value[name],
                            path + "[" + JSON.stringify(name) + "]"
                        );
                    });
                }
                return nu;
            }
            return value;
        }(object, "$"));
    };
}


if (typeof JSON.retrocycle !== "function") {
    JSON.retrocycle = function retrocycle($) {
        "use strict";

// Restore an object that was reduced by decycle. Members whose values are
// objects of the form
//      {$ref: PATH}
// are replaced with references to the value found by the PATH. This will
// restore cycles. The object will be mutated.

// The eval function is used to locate the values described by a PATH. The
// root object is kept in a $ variable. A regular expression is used to
// assure that the PATH is extremely well formed. The regexp contains nested
// * quantifiers. That has been known to have extremely bad performance
// problems on some browsers for very long strings. A PATH is expected to be
// reasonably short. A PATH is allowed to belong to a very restricted subset of
// Goessner's JSONPath.

// So,
//      var s = '[{"$ref":"$"}]';
//      return JSON.retrocycle(JSON.parse(s));
// produces an array containing a single element which is the array itself.

        var px = /^\$(?:\[(?:\d+|"(?:[^\\"\u0000-\u001f]|\\(?:[\\"\/bfnrt]|u[0-9a-zA-Z]{4}))*")\])*$/;

        (function rez(value) {

// The rez function walks recursively through the object looking for $ref
// properties. When it finds one that has a value that is a path, then it
// replaces the $ref object with a reference to the value that is found by
// the path.

            if (value && typeof value === "object") {
                if (Array.isArray(value)) {
                    value.forEach(function (element, i) {
                        if (typeof element === "object" && element !== null) {
                            var path = element.$ref;
                            if (typeof path === "string" && px.test(path)) {
                                value[i] = eval(path);
                            } else {
                                rez(element);
                            }
                        }
                    });
                } else {
                    Object.keys(value).forEach(function (name) {
                        var item = value[name];
                        if (typeof item === "object" && item !== null) {
                            var path = item.$ref;
                            if (typeof path === "string" && px.test(path)) {
                                value[name] = eval(path);
                            } else {
                                rez(item);
                            }
                        }
                    });
                }
            }
        }($));
        return $;
    };
}
        window.addEventListener('message', (event) => {
          if (event.data.action == "consoleEnter") {
            eval("console.log(" + JSON.stringify(event.data.code) + ");//@ sourceURL=console");

            if (event.data.code.indexOf("console") !== 0) {
              try {
                if (JSON.parse(event.data.code)) {
                  var type = "";
                  if (Array.isArray(JSON.parse(event.data.code))) {
                    var type = "Array: ";
                  }
                  else if (typeof JSON.parse(event.data.code) == "object") {
                    var type = "Object: "
                  }
                  eval("console.log('" + type + "' + " + JSON.stringify(event.data.code) + ");//@ sourceURL=console");
                }
              } catch (error) {
                if (typeof eval(event.data.code) == "object") {
                  var type = eval(event.data.code) instanceof Element ? "[HTMLElement]" : "[Object]";
                  eval("console.log('" + type + "');//@ sourceURL=console");
                }
                else {
                  eval("console.log(" + event.data.code + ");//@ sourceURL=console");
                }
              }
            }
            else {
              eval(event.data.code + "//@ sourceURL=console");

            }
          }
          else if (event.data.action = "go") {
            console.log(`Received message from parent: ${event.data.url}`);
            window.frameElement.contentWindow.Router.go(event.data.url);
          }
        });

        window.addEventListener('popstate', function (event) {
          window.parent.postMessage({
            action: "urlChange",
            url: "/" + router.location.pathname
          }, event);
        });

        (function (w) {
          "use strict";

          var A, F, O, consoleMethods, fixConsoleMethod, consoleOn,
            allHandlers, methodObj;

          A = [];
          F = function () { return; };
          O = {};

          // All possible standard methods to provide an interface for
          consoleMethods = [
            "assert", "clear", "count", "debug",
            "dir", "dirxml", "error", "exception",
            "group", "groupCollapsed", "groupEnd",
            "info", "log", "profile", "profileEnd",
            "table", "time", "timeEnd", "timeStamp",
            "trace", "warn"
          ];

          // Holds handlers to be executed for every method
          allHandlers = [];

          // Holds handlers per method
          methodObj = {};

          // Overrides the existing console methods, to call any stored handlers first
          fixConsoleMethod = (function () {
            var func, empty;

            empty = function () {
              return F;
            };

            if (w.console) {
              // If `console` is even available
              func = function (methodName) {
                var old;
                if (methodName in console && (old = console[methodName])) {
                  // Checks to see if `methodName` is defined on `console` and has valid function to execute
                  // (and stores the old handler)
                  // This is important so that undefined methods aren't filled in
                  console[methodName] = function () {
                    // Overwrites current console method with this function
                    var args, argsForAll, i, j;
                    // Copy all arguments passed to handler
                    args = A.slice.call(arguments, 0);
                    for (i = 0, j = methodObj[methodName].handlers.length; i < j; i++) {
                      // Loop over all stored handlers for this specific method and call them
                      F.apply.call(methodObj[methodName].handlers[i], console, args);
                    }
                    for (i = 0, j = allHandlers.length; i < j; i++) {
                      // Loop over all stored handlers for ALL events and call them
                      argsForAll = [methodName];
                      A.push.apply(argsForAll, args);


                      var file = new Error().stack.split("\n")[2].split("(");

                      file = file[1].split(":");
                      console.file = file[0];
                      console.line = file[1];
                      console.char = file[2].slice(0, -1);


                      F.apply.call(allHandlers[i], console, argsForAll);
                    }
                    // Calls old
                    F.apply.call(old, console, args);
                  };

                }
                return console[methodName] || empty;
              };
            } else {
              func = empty;
            }

            return func;
          }());

          // Loop through all standard console methods and add a wrapper function that calls stored handlers
          (function () {
            var i, j, cur;
            for (i = 0, j = consoleMethods.length; i < j; i++) {
              // Loop through all valid console methods
              cur = consoleMethods[i];
              methodObj[cur] = {
                handlers: []
              };
              fixConsoleMethod(cur);
            }
          }());

          // Main handler exposed
          consoleOn = function (methodName, callback) {
            var key, cur;
            if (O.toString.call(methodName) === "[object Object]") {
              // Object literal provided as first argument
              for (key in methodName) {
                // Loop through all keys in object literal
                cur = methodName[key];
                if (key === "all") {
                  // If targeting all events
                  allHandlers.push(cur);
                } else if (key in methodObj) {
                  // If targeting specific valid event
                  methodObj[key].handlers.push(cur);
                }
              }
            } else if (typeof methodName === "function") {
              // Function provided as first argument
              allHandlers.push(methodName);
            } else if (methodName in methodObj) {
              // Valid String event provided
              methodObj[methodName].handlers.push(callback);
            }
          };

          // Actually expose an interface
          w.ConsoleListener = {
            on: consoleOn
          };
        }(this));

        ConsoleListener.on(function (methodName, message) {
          self = this;
          window.parent.postMessage({
            action: "console",
            method: methodName,
            message: message,
            file: self.file,
            line: self.line,
            char: self.char
          }, event);
        });


        window.onerror = function (error, file, line, char) {
          if (file !== "console") {
            var file = file;
            var line = line;
            var char = char;
          }

          window.parent.postMessage({
            action: "console",
            method: "error",
            message: error,
            file,
            line,
            char
          }, event);
        };
      },
      changeURL(event) {
        var result = component.dom.querySelector("iframe#result").contentWindow;
        if (event.target) {
          var url = event.target.value;
          event.target.blur();
        }
        else {
          var url = event;
        }
        result.postMessage({
          action: "go",
          url: document.location.pathname + url.replace(/^\//, '')
        });
      },
      goBack(event) {
        data.currentUrlIndex -= 1;
        var url = data.urlHistory[data.currentUrlIndex - 1];
        component.methods.changeURL(url);
      },
      goNext(event) {
        data.currentUrlIndex += 1;
        var url = data.urlHistory[data.currentUrlIndex - 1];
        component.methods.changeURL(url);
      },
      sendJStoResult(event) {
        if (event.which == 13) {
          var result = component.dom.querySelector("iframe#result").contentWindow;
          var code = event.target.value;
          event.target.value = "";
          result.postMessage({ action: "consoleEnter", code: code });
        }
      },
      clearConsole(e) {
        data.console = [];
      },
      resize(e) {
        data.resize.x = true;
        e.preventDefault();
        component.dom.addEventListener("mousemove", function (me) {
          if (!data.resize.x) {
            return;
          }
          me.preventDefault();
          var containerWidth = component.dom.getRootNode().host.offsetWidth;
          var offsetRight = containerWidth - (me.clientX - component.dom.getRootNode().host.offsetLeft);
          var birim = containerWidth / 100;
          var offsetRight = 100 - (offsetRight / birim);
          data.editorWidth = offsetRight + "%";
          console.log("resize");
        });
        document.addEventListener("mouseup", function (e) {
          e.preventDefault();
          data.resize.x = false;
        });
      },
      openFileGotoLine(filename, line, char) {
        for (let i = 0; i < data.files.length; i++) {
          const file = data.files[i];
          if (file.filename == filename) {
            file.selected = true;
          }
          else {
            file.selected = false;
          }
        }
        var filenameSelector = filename.replace(/\./g, "\\.");

        var targetFile = component.dom.querySelector("#files .CodeMirror[selected=true]");
        var fileItself = component.dom.querySelector("#files .CodeMirror[filename='" + filenameSelector + "']");

        targetFile.setAttribute("selected", false);
        fileItself.setAttribute("selected", true);

        component.editors[filename].setCursor(line - 1, char - 1);
        component.editors[filename].refresh();
        component.editors[filename].focus();
      }
    }
    lifecycle = {
      beforeConstruct() {

      },
      afterFirstRender() {
        // listen messages from child
        window.addEventListener('message', (event) => {
          if (event.data.action == "urlChange") {
            data.url = event.data.url.replace(document.location.pathname, "");
            if (data.url !== data.urlHistory[data.currentUrlIndex - 1]) {
              data.urlHistory = data.urlHistory.slice(0, data.currentUrlIndex);
              data.urlHistory.push(data.url);
              data.currentUrlIndex += 1;
            };
          }
          else if (event.data.action == "console") {
            if (component.editors[event.data.file]) {
              var file = event.data.file;
              var line = event.data.line;
              var char = event.data.char;
            }
            data.console.push({
              method: event.data.method,
              message: event.data.message,
              file,
              line,
              char
            });
            var cnsl = component.dom.querySelector("#console");
            cnsl.scrollTop = cnsl.scrollHeight;
          }
        });

        if (typeof CodeMirror == "undefined") {
          loadJS("https://cdn.jsdelivr.net/combine/npm/codemirror@5.62.0/lib/codemirror.min.js,npm/codemirror@5.62.0/mode/javascript/javascript.min.js,npm/codemirror@5.62.0/mode/css/css.min.js,npm/codemirror@5.62.0/mode/xml/xml.min.js,npm/codemirror@5.62.0/mode/htmlmixed/htmlmixed.min.js,npm/codemirror@5.62.0/addon/display/autorefresh.min.js,npm/codemirror-formatting@1.0.0/formatting.min.js,npm/jszip@3.1.5/dist/jszip.min.js", function () {
            var slot = component.dom.querySelector('slot[name=files]');
            var files = slot.assignedNodes()[0].querySelectorAll("textarea");
            component.editors = [];
            for (let index = 0; index < files.length; index++) {
              var fileEl = files[index];
              var filename = fileEl.getAttribute("filename");
              var fileContent = fileEl.value;
              var isFileSelected = fileEl.hasAttribute("selected");
              data.files.push({
                filename: filename,
                selected: isFileSelected
              });
            }

            for (var index = 0; index < files.length; index++) {
              var textarea = files[index];
              var filename = files[index].getAttribute("filename");
              var selected = files[index].hasAttribute("selected");
              var targetEl = component.dom.querySelector("ul#files");

              // remove unnecessary indents
              var indent = textarea.value.split('\n').join('').match(/^\s*/)[0].length;
              var text = textarea.value.trim();
              var a = new RegExp("^\\s{" + indent + "}", "gm");
              text = text.replace(a, "");

              component.editors[textarea.getAttribute("filename")] = CodeMirror(function (node) {
                node.setAttribute("filename", filename);
                node.setAttribute("selected", selected);
                targetEl.appendChild(node, targetEl);
              }, {
                value: text,
                autoRefresh: { delay: 0 },
                lineNumbers: true,
                gutter: true,
                smartIndent: true,
                mode: "htmlmixed",
                theme: 'default', // ambiance, ayu-mirage, cobalt, dracula, material, rubyblue, nord
                styleActiveLine: true,
              });

              component.editors[textarea.getAttribute("filename")].on("change", function () {
                component.methods.renderResult();
              });

              var currentHandle = null, currentLine;
              component.editors[files[index].getAttribute("filename")].on("cursorActivity", function (cm) {
                var line = cm.getCursor().line;
                var handle = cm.getLineHandle(line);

                if (currentHandle) {
                  cm.removeLineClass(currentHandle, "wrap", "activeline");
                }
                currentHandle = handle; currentLine = line;
                cm.addLineClass(currentHandle, null, "activeline");
              });
            }

            component.methods.renderResult();

            var cmInitCheck = setInterval(() => {
              var px = parseInt(component.dom.querySelector(".CodeMirror[selected=true] > div:first-child").style.left.replace("px", ""));
              if (px > 100) {
                component.editors["index.html"].refresh();
              }
              else {
                clearInterval(cmInitCheck);
              }
            }, 10);
          })
        }
      },
    }
  }
</script>