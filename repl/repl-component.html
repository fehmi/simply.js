<template>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/codemirror@5.62.0/lib/codemirror.min.css" />
  <header>
    <if data.props.title>
      <div class="inputContainer">
        <input class="title" value="{ data.props.title}" readonly onclick="titleFocus(event);"
          oninput="titleInput(event);" onchange="titleRename(event);" onblur="titleRename(event);">
        <div class="ghost-input">{ data.props.title}</div>
      </div>
    </if>
    <div class="buttons">
      <if data.props.download==true>
        <button onclick="download()">Download</button>
      </if>
      <if data.props.save==true>
        <button>Save</button>
      </if>
      <if data.props.fullscreen==true>
        <button onclick="fullscreenToggle()">Fullscreen</button>
      </if>
    </div>
  </header>

  <div id="topArea">
    <div id="editor">
      <ul id="file-tabs">
        <each data.files as file>
          <li filename="{file.filename}" selected="{ file.selected }" onclick="changeSelectedFile(event);">
            <div class="inputContainer">
              <input class="filename" value="{file.filename.replace('.html', '')}" readonly
                onclick="focusFilename(event);" oninput="inputFilename(event);" onchange="renameFilename(event);">
              <div class="ghost-input">{file.filename.replace('.html', '')}</div>
            </div>
            <div class="extension">.html</div>
            <div class="delete" onclick="deleteFile(event)">✕</div>
          </li>
        </each>
        <li class="add" onclick="addFile()">+</li>
      </ul>

      <ul id="files" passive>
        <slot name="files"></slot>
      </ul>
    </div>
    <div class="v-resizer" onmousedown="resize(event)"></div>
    <div id="result">
      <div id="result-header">
        Result
      </div>
      <div id="addressbar">
        <!-- {data.urlHistory.length} - {data.currentUrlIndex} -->
        <button {(data.currentUrlIndex < 2) ? "disabled" : "" } onclick="goBack(event);"></button>
        <button {(data.currentUrlIndex> data.urlHistory.length - 1) ? "disabled" : ""}
          onclick="goNext(event);"></button>
        <input type="text" value="{data.url}" id="url" onchange="changeURL(event)">
      </div>
      <iframe id="result" name="result" {(data.resize.x || data.resize.y) ? "resizing" : "" }></iframe>
    </div>
  </div>
  <div class="h-resizer" onmousedown="resize(event)"></div>
  <div id="console">
    <label>CONSOLE <a onclick="clearConsole(event)">Clear</a></label>
    <div class="messages">
      <ul>
        <each data.console as entry>
          <li class="{entry.method}">{entry.message} <if entry.file>(<span class="debugLink"
                onclick="openFileGotoLine('{entry.file}', '{entry.line}','{entry.char}')">{entry.file}:{entry.line}:{entry.char}</span>)
            </if>
          </li>
        </each>
      </ul>
      <div><input placeholder=">_" name="consoleEntry" onkeyup="sendJStoResult(event)"></div>
    </div>


  </div>
</template>

<style>
  :host {
    display: flex;
    width: 960px;
    height: 550px;
    border: 2px solid #dddddd;
    font-family: Arial, Helvetica, sans-serif;
    flex-direction: column;
  }

  :host(.fullscreen) {
    position: fixed;
    width: 100%;
    height: 100%;
    left: 0;
    top: 0;
  }

  header {
    background-color: #677876;
    color: white;
    height: 40px;
    display: flex;
    align-items: center;
    padding: 0px 10px;
    margin-left: -2px;
    width: calc(100% + 4px);
    box-sizing: border-box;
    margin-top: -2px;
    justify-content: space-between;
  }

  slot[name=files] {
    display: none;
  }

  #topArea {
    display: flex;
    height: 80%;
    height: calc(100% - "{data.topAreaHeight}");
    max-height: calc(100% - 30px);
  }

  #editor {
    display: flex;
    flex-direction: column;
    width: "{data.editorWidth}";
    min-width: 30%;
    max-width: 70%;
  }

  #result {
    display: flex;
    flex-direction: column;
    border-left: 2px solid #dddddd;
    box-sizing: border-box;
    flex: 1;
  }

  .v-resizer {
    cursor: ew-resize;
    width: 1px;
    position: relative;
  }

  .v-resizer:after {
    content: "";
    display: block;
    height: 100%;
    width: 8px;
    position: absolute;
    z-index: 10;
  }

  .h-resizer {
    cursor: ns-resize;
    height: 1px;
    width: 100%;
    position: relative;
  }

  .h-resizer:after {
    content: "";
    display: block;
    width: 100%;
    height: 8px;
    position: absolute;
    left: -2px;
    z-index: 10;
  }

  #console {
    border-top: 2px solid #dddddd;
    flex: 1;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  #console .messages {
    list-style: none;
    font-family: monospace;
    padding: 0;
    margin: 0px;
    overflow: auto;
    position: absolute;
    top: 26px;
    left: 0;
    right: 0;
    bottom: 0;
  }

  #console .messages ul {
    list-style: none;
    font-family: monospace;
    padding: 0;
    margin: 0px;
  }

  #console .messages li {
    border-color: #d4d4d4;
    border-style: solid;
    border-width: 1px 0px;
    padding: 3px 10px;
    margin-top: -1px;
    font-size: 12px;
  }

  #console .messages li.error {
    border-color: #fed6d7;
    background-color: #fff0f0;
    color: #fc0d1b;
  }

  #console .messages li.warn {
    border-color: #f3e5a7;
    background-color: #fffbe6;
    color: #5c3c08;
  }

  #console label {
    background-color: #f1f1f1;
    width: 100%;
    display: block;
    font-family: monospace;
    font-size: 14px;
    padding: 5px 10px;
    box-sizing: border-box;
    color: #666666;
    position: sticky;
    top: 0px;
  }

  input[name=consoleEntry] {
    font-family: monospace;
    border: none;
    padding: 5px 10px;
    font-size: 12px;
    outline: none;
    width: 100%;
  }

  #file-tabs {
    /* border-bottom: 2px solid #dddddd; */
    line-height: 35px;
    overflow: overlay;
    -webkit-background-clip: text;
    background-clip: text;
    background-color: rgba(0, 0, 0, 0);
    transition: background-color .8s;
    height: 35px;
    position: relative;
  }

  #file-tabs:before {
    content: "";
    width: 100%;
    position: absolute;
    background-color: #f1f1f1;
    height: 100%;
  }

  .CodeMirror-vscrollbar,
  .CodeMirror-hscrollbar {
    -webkit-background-clip: text;
    background-clip: text;
    background-color: rgba(0, 0, 0, 0);
    transition: background-color .8s;
  }

  #file-tabs::-webkit-scrollbar,
  .CodeMirror-hscrollbar::-webkit-scrollbar {
    width: 5px;
    height: 5px;
  }

  .CodeMirror-vscrollbar::-webkit-scrollbar {
    width: 10px;
  }

  .CodeMirror-hscrollbar::-webkit-scrollbar {
    height: 10px;
  }

  #file-tabs::-webkit-scrollbar-track,
  .CodeMirror-vscrollbar::-webkit-scrollbar-track,
  .CodeMirror-hscrollbar::-webkit-scrollbar-track {
    background-color: transparent;

  }

  #file-tabs::-webkit-scrollbar-thumb,
  .CodeMirror-vscrollbar::-webkit-scrollbar-thumb,
  .CodeMirror-hscrollbar::-webkit-scrollbar-thumb {
    background-color: rgb(206, 206, 206);
  }


  #file-tabs::-webkit-scrollbar-thumb,
  .CodeMirror-vscrollbar::-webkit-scrollbar-thumb,
  .CodeMirror-hscrollbar::-webkit-scrollbar-thumb {
    background-color: inherit;
  }

  #file-tabs:hover,
  .CodeMirror:hover .CodeMirror-vscrollbar,
  .CodeMirror:hover .CodeMirror-hscrollbar {
    background-color: rgb(206, 206, 206);
  }

  .CodeMirror-linenumber.CodeMirror-gutter-elt {
    transform: translateX(-20px);
  }

  .CodeMirror-lines {
    padding-left: 20px;
    padding-top: 20px;
  }

  #file-tabs li {
    position: relative;
    cursor: pointer;
    padding: 0px 15px;
    font-size: 14px;
    color: #888;
    white-space: nowrap;
    background-color: #f1f1f1;
    display: flex;
  }

  #file-tabs .add {
    font-size: 22px;
    padding: 0px 10px 0px 10px;
  }

  #file-tabs .delete {
    opacity: 0;
    pointer-events: none;
    transition: opacity 500ms;
  }

  #file-tabs li[selected=true] .delete {
    opacity: 1;
    pointer-events: all;
    cursor: pointer;
  }

  #file-tabs li[selected=false]:hover .delete {
    opacity: 1;
    pointer-events: all;
  }

  #file-tabs li:first-child input {
    pointer-events: none;
  }

  #file-tabs li:first-child .delete {
    pointer-events: none;
    display: none;
  }


  #file-tabs li[selected=true] {
    cursor: default;
    background-color: white;
    color: #292;
  }

  .inputContainer {
    position: relative;
  }

  input.filename {
    position: absolute;
    width: 100%;
    padding: 0;
    margin-top: 10px;
    border: none;
    cursor: pointer;
    outline: none;
  }

  #file-tabs li[selected=true] input.filename {
    cursor: text;
  }

  .ghost-input {
    font-size: 13.3333px;
    min-width: 3px;
  }

  input.title {
    position: absolute;
    width: 100%;
    padding: 0;
    outline: 0;
    border: none;
    font-size: 16px;
    background: none;
    color: white;
    z-index: 1;
    margin-top: -9px;
  }

  input.title+.ghost-input {
    font-size: 16px;
    z-index: 0;
    opacity: 0;
    height: 0px;
    padding-right: 50px;
  }

  /*
  #file-tabs li[selected=true]::after {
    content: "";
    position: absolute;
    width: 100%;
    height: 3px;
    background-color: #292;
    bottom: 0px;
    left: 0px;
  }
  */

  #result-header {
    border-bottom: 2px solid #dddddd;
    line-height: 35px;
    font-size: 14px;
    padding: 0px 15px;
  }

  #file-tabs,
  #files {
    display: flex;
    list-style: none;
    padding: 0px;
    margin: 0px;
  }

  #files {
    flex: 1;
    flex-direction: column;
    height: 0px;
  }

  .CodeMirror {
    height: 100%;
    width: 100%;
    display: none;
    line-height: 20px;
  }

  .CodeMirror[selected=true] {
    display: block;
  }

  #files textarea,
  iframe#result {
    width: 100%;
    height: 100%;
    border: none;
  }

  iframe#result[resizing] {
    pointer-events: none;
  }

  #addressbar {
    display: flex;
    align-items: center;
  }

  #addressbar button {
    background-size: contain;
    background-repeat: no-repeat;
    width: 17px;
    height: 17px;
    border: none;
    cursor: pointer;
  }

  #addressbar button:disabled {
    opacity: .4;
    cursor: default;
  }

  #addressbar button:nth-child(1) {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'%3E%3Ctitle%3Eicon-arrow-left%3C/title%3E%3Cpolyline points='20.6 8 5.62 24.1 20.6 40.2' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/polyline%3E%3Cline x1='7.53' y1='24.1' x2='42.33' y2='24.1' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/line%3E%3C/svg%3E");
    margin-right: 10px;
  }

  #addressbar button:nth-child(2) {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'%3E%3Ctitle%3Eicon-arrow-right%3C/title%3E%3Cpolyline points='27.35 40.2 42.33 24.1 27.35 8' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/polyline%3E%3Cline x1='40.42' y1='24.1' x2='5.62' y2='24.1' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/line%3E%3C/svg%3E");
  }

  div#addressbar {
    background-color: #f2f3f7;
    border-bottom: 1px solid #ced0dd;
    padding: 10px 10px;
  }

  input#url {
    flex: 1;
    border-radius: 3px;
    outline: none;
    box-shadow: none;
    border: 1px solid #ced0dd;
    padding: 0px 10px;
    line-height: 26px;
    font-size: 14px;
    margin-left: 10px;
    transition: all ease-in .1s;
  }

  input#url:focus {
    border: 1px solid #9ec5ef;
    box-shadow: 0 2px 8px 0 rgb(0 0 0 / 8%);
  }

  .debugLink {
    color: black;
    text-decoration: underline;
    cursor: pointer;
  }

  .activeline {
    position: relative;
    background-color: rgba(0, 0, 0, .04);
  }
</style>

<script>
  class {
    data = {
      files: [],
      url: "/",
      urlHistory: [
        "/"
      ],
      currentUrlIndex: 1,
      console: [],
      resize: {
        x: false,
        y: false
      },
      editorWidth: "65%",
      topAreaHeight: "120px"
    }
    methods = {
      renderResult() {


        var indexContent = component.editors["index.html"].getValue();
        var files = component.methods.rewriteGet("index.html", indexContent);
        var blobs = [];

        for (let index = 0; index < Object.keys(files).length; index++) {
          var file = files[Object.keys(files).reverse()[index]];

          for (const filename in file) {
            if (blobs[filename] == undefined) {
              var newContent = file["content"];
              var m;
              var regex = /(?<!\/\/(\s+)?)get\((\[)?([\s\S]*?)?(.*)\)(\;)?/gm;

              while ((m = regex.exec(file["content"])) !== null) {
                // This is necessary to avoid infinite loops with zero-width matches
                if (m.index === regex.lastIndex) {
                  regex.lastIndex++;
                }
                if (m[4].indexOf("]") > -1) { // multi
                  var filenames = m[4].replace(/((\\n)|[\\\s\"\[\]])/g, "");
                  var filenames = filenames.split(",");
                  var get = m[0];
                  var newGet = "";
                  for (let i = 0; i < filenames.length; i++) {
                    var fn = filenames[i].replace(/\'\"/g, '');;
                    newGet += "get('" + blobs[fn].blobUrl + "', '" + fn + "');";
                  }
                  newContent = newContent.replace(get, newGet);
                }
                else {
                  var fn = m[4].slice(0, -1);
                  var get = m[0];
                  var newGet = "get('" + blobs[fn].blobUrl + "', '" + fn + "');";
                  newContent = newContent.replace(get, newGet);
                }
              }

              var blob = new Blob([newContent], { type: "text/html; charset=utf-8" });
              var blobUrl = URL.createObjectURL(blob);
              blobs[file["filename"]] = {
                filename: file["filename"],
                blobUrl: blobUrl,
                content: newContent
              };
            }
          }
        }
        var runInResult = "<script>function " + component.methods.runInResult.toString() + "runInResult();<\/script>";
        var base = "<head><base href=" + document.location.href + ">";
        blobs["index.html"].content = blobs["index.html"].content.replace("<head>", base) + runInResult;

        // component.dom.querySelector("iframe").setAttribute("src", "about:blank");
        component.dom.querySelector("iframe").setAttribute("srcdoc", "");
        component.dom.querySelector("iframe").addEventListener("load", function bas() {
          console.log("load");
          component.dom.querySelector("iframe").removeEventListener("load", bas);
          //component.dom.querySelector("iframe").removeAttribute("src");
          component.dom.querySelector("iframe").contentWindow.document.write(blobs["index.html"].content);
          // rever url
          data.urlHistory = [data.urlHistory[0]];
          data.url = data.urlHistory[0];
          data.currentUrlIndex = 1;
          data.console = [];

        });

      },
      rewriteGet(filename, content) {
        var regex = /(?<!\/\/(\s+)?)get\((\[)?([\s\S]*?)?(.*)\)(\;)?/gm;
        var regex2 = /(?<!\/\/(\s+)?)get\((\[)?([\s\S]*?)?(.*)\)(\;)?/gm;
        var blobs = "";
        let m;
        let mm;

        if (!component.files) {
          component.files = [];
        }

        if (!component.files[i]) {
          component.files[filename] = {};
        }

        while ((m = regex.exec(content)) !== null) {
          // This is necessary to avoid infinite loops with zero-width matches
          if (m.index === regex.lastIndex) {
            regex.lastIndex++;
          }

          if (m[4].indexOf("]") > -1) {

            var f = m[4].replace(/((\\n)|[\\\s\"\[\]])/g, "");
            var fns = f.split(",");
            for (let i = 0; i < fns.length; i++) {
              const fn = fns[i].replace(/\'\"/g, '');
              var nestedComponentContent = component.editors[fn].getValue();

              while ((mm = regex2.exec(content)) !== null) {
                var nnestedComponentContent = component.editors[fn].getValue();;
                component.methods.rewriteGet(fn, nnestedComponentContent);
              }
            }
          }

          else {
            var fn = m[4].slice(0, -1);
            var nestedComponentContent = component.editors[fn].getValue();

            while ((mm = regex2.exec(content)) !== null) {
              var nnestedComponentContent = component.editors[fn].getValue();;
              component.methods.rewriteGet(fn, nnestedComponentContent);
            }
          }
        }

        component.files[filename]["content"] = content;
        component.files[filename]["filename"] = filename;
        return component.files;
      },
      changeSelectedFile(event) {
        event.preventDefault();
        event.stopPropagation();
        var filename = event.currentTarget.getAttribute("filename");
        console.log(event.currentTarget);
        var filenameSelector = filename.replace(/\./g, "\\.");

        for (let i = 0; i < data.files.length; i++) {
          var fn = data.files[i]["filename"];
          if (filename == fn) {
            data.files[i]["selected"] = true;
          }
          else {
            data.files[i]["selected"] = false;
          }
        }

        var targetFile = component.dom.querySelector("#files .CodeMirror[selected=true]");
        var fileItself = component.dom.querySelector("#files .CodeMirror[filename='" + filenameSelector + "']");

        targetFile.setAttribute("selected", false);
        fileItself.setAttribute("selected", true);

        component.editors[filename].refresh();
        component.editors[filename].focus();

      },
      runInResult() {
        window.addEventListener('message', (event) => {
          if (event.data.action == "consoleEnter") {
            eval("console.log(" + JSON.stringify(event.data.code) + ");//@ sourceURL=console");

            if (event.data.code.indexOf("console") !== 0) {
              try {
                if (JSON.parse(event.data.code)) {
                  var type = "";
                  if (Array.isArray(JSON.parse(event.data.code))) {
                    var type = "Array: ";
                  }
                  else if (typeof JSON.parse(event.data.code) == "object") {
                    var type = "Object: "
                  }
                  eval("console.log('" + type + "' + " + JSON.stringify(event.data.code) + ");//@ sourceURL=console");
                }
              } catch (error) {
                if (typeof eval(event.data.code) == "object") {
                  var type = eval(event.data.code) instanceof Element ? "[HTMLElement]" : "[Object]";
                  eval("console.log('" + type + "');//@ sourceURL=console");
                }
                else {
                  eval("console.log(" + event.data.code + ");//@ sourceURL=console");
                }
              }
            }
            else {
              eval(event.data.code + "//@ sourceURL=console");

            }
          }
          else if (event.data.action = "go") {
            console.log(`Received message from parent: ${event.data.url}`);
            window.frameElement.contentWindow.Router.go(event.data.url);
          }
        });

        window.addEventListener('popstate', function (event) {
          window.parent.postMessage({
            action: "urlChange",
            url: "/" + router.location.pathname
          }, event);
        });

        (function (w) {
          "use strict";

          var A, F, O, consoleMethods, fixConsoleMethod, consoleOn,
            allHandlers, methodObj;

          A = [];
          F = function () { return; };
          O = {};

          // All possible standard methods to provide an interface for
          consoleMethods = [
            "assert", "clear", "count", "debug",
            "dir", "dirxml", "error", "exception",
            "group", "groupCollapsed", "groupEnd",
            "info", "log", "profile", "profileEnd",
            "table", "time", "timeEnd", "timeStamp",
            "trace", "warn"
          ];

          // Holds handlers to be executed for every method
          allHandlers = [];

          // Holds handlers per method
          methodObj = {};

          // Overrides the existing console methods, to call any stored handlers first
          fixConsoleMethod = (function () {
            var func, empty;

            empty = function () {
              return F;
            };

            if (w.console) {
              // If `console` is even available
              func = function (methodName) {
                var old;
                if (methodName in console && (old = console[methodName])) {
                  // Checks to see if `methodName` is defined on `console` and has valid function to execute
                  // (and stores the old handler)
                  // This is important so that undefined methods aren't filled in
                  console[methodName] = function () {
                    // Overwrites current console method with this function
                    var args, argsForAll, i, j;
                    // Copy all arguments passed to handler
                    args = A.slice.call(arguments, 0);
                    for (i = 0, j = methodObj[methodName].handlers.length; i < j; i++) {
                      // Loop over all stored handlers for this specific method and call them
                      F.apply.call(methodObj[methodName].handlers[i], console, args);
                    }
                    for (i = 0, j = allHandlers.length; i < j; i++) {
                      // Loop over all stored handlers for ALL events and call them
                      argsForAll = [methodName];
                      A.push.apply(argsForAll, args);


                      var file = new Error().stack.split("\n")[2].split("(");

                      file = file[1].split(":");
                      console.file = file[0];
                      console.line = file[1];
                      console.char = file[2].slice(0, -1);


                      F.apply.call(allHandlers[i], console, argsForAll);
                    }
                    // Calls old
                    F.apply.call(old, console, args);
                  };

                }
                return console[methodName] || empty;
              };
            } else {
              func = empty;
            }

            return func;
          }());

          // Loop through all standard console methods and add a wrapper function that calls stored handlers
          (function () {
            var i, j, cur;
            for (i = 0, j = consoleMethods.length; i < j; i++) {
              // Loop through all valid console methods
              cur = consoleMethods[i];
              methodObj[cur] = {
                handlers: []
              };
              fixConsoleMethod(cur);
            }
          }());

          // Main handler exposed
          consoleOn = function (methodName, callback) {
            var key, cur;
            if (O.toString.call(methodName) === "[object Object]") {
              // Object literal provided as first argument
              for (key in methodName) {
                // Loop through all keys in object literal
                cur = methodName[key];
                if (key === "all") {
                  // If targeting all events
                  allHandlers.push(cur);
                } else if (key in methodObj) {
                  // If targeting specific valid event
                  methodObj[key].handlers.push(cur);
                }
              }
            } else if (typeof methodName === "function") {
              // Function provided as first argument
              allHandlers.push(methodName);
            } else if (methodName in methodObj) {
              // Valid String event provided
              methodObj[methodName].handlers.push(callback);
            }
          };

          // Actually expose an interface
          w.ConsoleListener = {
            on: consoleOn
          };
        }(this));

        ConsoleListener.on(function (methodName, message) {
          self = this;
          window.parent.postMessage({
            action: "console",
            method: methodName,
            message: message,
            file: self.file,
            line: self.line,
            char: self.char
          }, event);
        });


        window.onerror = function (error, file, line, char) {
          if (file !== "console") {
            var file = file;
            var line = line;
            var char = char;
          }

          window.parent.postMessage({
            action: "console",
            method: "error",
            message: error,
            file,
            line,
            char
          }, event);
        };
      },
      changeURL(event) {
        var result = component.dom.querySelector("iframe#result").contentWindow;
        if (event.target) {
          var url = event.target.value;
          event.target.blur();
        }
        else {
          var url = event;
        }
        result.postMessage({
          action: "go",
          url: document.location.pathname + url.replace(/^\//, '')
        });
      },
      goBack(event) {
        data.currentUrlIndex -= 1;
        var url = data.urlHistory[data.currentUrlIndex - 1];
        component.methods.changeURL(url);
      },
      goNext(event) {
        data.currentUrlIndex += 1;
        var url = data.urlHistory[data.currentUrlIndex - 1];
        component.methods.changeURL(url);
      },
      sendJStoResult(event) {
        if (event.which == 13) {
          var result = component.dom.querySelector("iframe#result").contentWindow;
          var code = event.target.value;
          event.target.value = "";
          result.postMessage({ action: "consoleEnter", code: code });
          component.dom.querySelector("input[name=consoleEntry]").focus();

        }
      },
      clearConsole(e) {
        data.console = [];
      },
      resize(e) {
        var direction = e.target.className == "v-resizer" ? "v" : "h";
        if (direction == "v") {
          data.resize.x = true;
        }
        else {
          data.resize.y = true;
        }

        e.preventDefault();
        component.dom.addEventListener("mousemove", function (me) {
          if (!data.resize.x && !data.resize.y) {
            return;
          }
          me.preventDefault();
          var containerWidth = component.dom.getRootNode().host.offsetWidth;
          var containerHeight = component.dom.getRootNode().host.offsetHeight;

          if (data.resize.x) {
            var offsetRight = containerWidth - (me.clientX - component.dom.getRootNode().host.offsetLeft);
            var birim = containerWidth / 100;
            offsetRight = 100 - (offsetRight / birim);
            data.editorWidth = offsetRight + "%";
            console.log(offsetRight);
          }
          else {
            var offsetTop = containerHeight - (me.clientY - component.dom.getRootNode().host.offsetTop);
            data.topAreaHeight = Math.abs(offsetTop) + "px";
          }
        });
        document.addEventListener("mouseup", function (e) {
          e.preventDefault();
          data.resize.x = false;
          data.resize.y = false;
        });
      },
      openFileGotoLine(filename, line, char) {
        for (let i = 0; i < data.files.length; i++) {
          const file = data.files[i];
          if (file.filename == filename) {
            file.selected = true;
          }
          else {
            file.selected = false;
          }
        }
        var filenameSelector = filename.replace(/\./g, "\\.");

        var targetFile = component.dom.querySelector("#files .CodeMirror[selected=true]");
        var fileItself = component.dom.querySelector("#files .CodeMirror[filename='" + filenameSelector + "']");

        targetFile.setAttribute("selected", false);
        fileItself.setAttribute("selected", true);

        component.editors[filename].setCursor(line - 1, char - 1);
        component.editors[filename].refresh();
        component.editors[filename].focus();
      },
      focusFilename(e) {
        var selected = e.target.parentElement.parentElement.getAttribute("selected");
        if (selected == "true") {
          e.stopPropagation();
          e.target.readOnly = false;
          e.target.focus();
        }
      },
      inputFilename(e) {
        var ghost = e.target.parentElement.parentElement.querySelector(".ghost-input");
        ghost.innerHTML = e.target.value;
      },
      renameFilename(e) {
        var oldName = e.target.parentElement.parentElement.getAttribute("filename");
        var newName = e.target.value;
        if (newName !== "" && !component.editors[newName + ".html"]) {
          console.log("hem boş değil hem duplicate değil");
          for (let i = 0; i < data.files.length; i++) {
            const file = data.files[i];
            if (file.filename == oldName) {
              newName += ".html";
              file.filename = newName;
              component.editors[newName] = component.editors[oldName];
              delete component.editors[oldName];
              component.dom.querySelector(".CodeMirror[filename='" + oldName + "']").setAttribute("filename", newName);
              console.log(component.editors[newName]);
            }
          }
          component.methods.renderResult();
        }
        else {
          console.log("boş ya da duplicate");
          e.target.focus();
          return false;
        }
      },
      deleteFile(e) {
        e.stopPropagation();
        var filename = e.target.parentElement.getAttribute("filename");

        component.editors[filename].setOption("mode", "text/x-csrc");
        component.editors[filename].getWrapperElement().remove();
        delete component.editors[filename];

        for (let i = 0; i < data.files.length; i++) {
          const file = data.files[i];
          if (file.filename == filename) {
            data.files.splice(i, 1);
            console.log(data.files);


            filename = data.files[i - 1].filename;
            var filenameSelector = filename.replace(/\./g, "\\.");
            var targetFile = component.dom.querySelector("#files .CodeMirror[selected=true]");
            if (!targetFile) {
              data.files[i - 1].selected = true;
              var fileItself = component.dom.querySelector("#files .CodeMirror[filename='" + filenameSelector + "']");
              fileItself.setAttribute("selected", true);
            }
          }
        }
        component.methods.renderResult();
        return false;
      },
      addFile() {
        var i = 1;
        var filename = "component-" + i + ".html";
        while (component.editors["component-" + i + ".html"]) {
          i = i + 1;
        }
        filename = "component-" + i + ".html";
        for (let i = 0; i < data.files.length; i++) {
          const file = data.files[i];
          file.selected = false;
        }
        data.files.push({ "filename": filename, "selected": true });

        var fileTabs = component.dom.querySelector("#file-tabs");
        fileTabs.scrollLeft = fileTabs.scrollWidth;

        var filenameInput = component.dom.querySelector("li[filename=" + filename.replace(/\./g, "\\.") + "] input");
        var template = "<template>\n\n</template>\n\n<style>\n::host {\n\n}\n</style>\n\n<script>\nclass \{\n\n\}\n<\/script>";


        var target = component.dom.querySelector("ul#files");
        component.methods.createNewCodemirror(filename, true, target, template);

        filenameInput.click();
        filenameInput.setSelectionRange(0, filenameInput.value.length);

        component.dom.querySelector("#files .CodeMirror[selected=true]").setAttribute("selected", false);
        //component.editors[filename].setCursor({ line: 1, ch: 0 });
        component.files[filename] = {
          filename: filename,
          content: template
        }
        console.log(component.files);
      },
      createNewCodemirror(filename, selected, targetEl, text) {
        component.editors[filename] = CodeMirror(function (node) {
          node.setAttribute("filename", filename);
          node.setAttribute("selected", selected);
          targetEl.appendChild(node, targetEl);
        }, {
          value: text,
          autoRefresh: { delay: 0 },
          lineNumbers: true,
          gutter: true,
          smartIndent: true,
          autofocus: true,
          mode: "htmlmixed",
          theme: 'default', // ambiance, ayu-mirage, cobalt, dracula, material, rubyblue, nord
          styleActiveLine: true,
        });
        var render;
        component.editors[filename].on("changes", function (a, b, c, d) {
          try {
            clearTimeout(render);
          } catch (error) { }
          render = setTimeout(function () {
            component.methods.renderResult();
          }, 250); // How long do you want the delay to be (in milliseconds)?
        });

        var currentHandle = null, currentLine;
        component.editors[filename].on("cursorActivity", highlight);
        component.editors[filename].on("focus", highlight);

        function highlight(cm) {
          var line = cm.getCursor().line;
          var handle = cm.getLineHandle(line);

          if (currentHandle) {
            cm.removeLineClass(currentHandle, "wrap", "activeline");
          }
          currentHandle = handle;
          currentLine = line;
          cm.addLineClass(currentHandle, null, "activeline");
        }
      },
      fullscreenToggle() {
        if (component.dom.getRootNode().host.className.indexOf("fullscreen") > -1) {
          component.dom.getRootNode().host.classList.remove("fullscreen");
        }
        else {
          component.dom.getRootNode().host.classList.add("fullscreen");
        }

      },
      titleFocus(e) {
        e.stopPropagation();
        e.target.readOnly = false;
        e.target.focus();
      },
      titleInput(e) {
        var ghost = e.target.parentElement.querySelector(".ghost-input");
        ghost.innerHTML = e.target.value;
      },
      titleRename(e) {
        if (e.target.value.length !== 0) {
          data.props.title = e.target.value;
          e.target.blur();
        }
        else {
          e.target.focus();
        }

        console.log("yeah");
      },
      download() {
        var license = 'MIT License \n\
Copyright (c) '+new Date().getFullYear()+' simply.js \n\
\n\
Permission is hereby granted, free of charge, to any person obtaining a copy\n\
of this software and associated documentation files (the "Software"), to deal\n\
in the Software without restriction, including without limitation the rights\n\
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\
copies of the Software, and to permit persons to whom the Software is\n\
furnished to do so, subject to the following conditions:\n\
\n\
The above copyright notice and this permission notice shall be included in all\n\
copies or substantial portions of the Software.\n\
\n\
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\
SOFTWARE.';
        var zip = new JSZip();
        //zip.file("Hello.txt", "Hello World\n");
        //var img = zip.folder("images");
        //img.file("smile.gif", imgData, { base64: true });
        for (let i = 0; i < data.files.length; i++) {
          var filename = data.files[i].filename;
          var editor = component.editors[filename];
          var content = editor.getValue();
          zip.file(filename, content);
          zip.file("LICENSE", license)
          zip.file("readme.md", "Welcome to simply.js");
        }
        zip.generateAsync({ type: "blob" }).then(function (content) {
          // see FileSaver.js
          saveAs(content, data.props.title + ".zip");
        });
      }
    }
    lifecycle = {
      beforeConstruct() {

      },
      afterFirstRender() {
        window.onerror = function (error, file, line, char) {
          data.console = [];
          data.console.push({
            method: "error",
            message: error
          });
        };
        // listen messages from child
        window.addEventListener('message', (event) => {
          if (event.data.action == "urlChange") {
            data.url = event.data.url.replace(document.location.pathname, "");
            if (data.url !== data.urlHistory[data.currentUrlIndex - 1]) {
              data.urlHistory = data.urlHistory.slice(0, data.currentUrlIndex);
              data.urlHistory.push(data.url);
              data.currentUrlIndex += 1;
            };
          }
          else if (event.data.action == "console") {
            if (component.editors[event.data.file]) {
              var file = event.data.file;
              var line = event.data.line;
              var char = event.data.char;
            }
            data.console.push({
              method: event.data.method,
              message: event.data.message,
              file,
              line,
              char
            });
            var messages = component.dom.querySelector("#console .messages");
            messages.scrollTop = messages.scrollHeight;
          }
        });

        if (typeof CodeMirror == "undefined") {
          loadJS("https://cdn.jsdelivr.net/combine/npm/codemirror@5.62.0/lib/codemirror.min.js,npm/codemirror@5.62.0/mode/javascript/javascript.min.js,npm/codemirror@5.62.0/mode/css/css.min.js,npm/codemirror@5.62.0/mode/xml/xml.min.js,npm/codemirror@5.62.0/mode/htmlmixed/htmlmixed.min.js,npm/codemirror@5.62.0/addon/display/autorefresh.min.js,npm/codemirror-formatting@1.0.0/formatting.min.js,npm/jszip@3.1.5/dist/jszip.min.js,npm/filesaver.js@1.3.4/FileSaver.min.js", function () {
            var slot = component.dom.querySelector('slot[name=files]');
            var files = slot.assignedNodes()[0].querySelectorAll("textarea");
            component.editors = [];
            for (let index = 0; index < files.length; index++) {
              var fileEl = files[index];
              var filename = fileEl.getAttribute("filename");
              var fileContent = fileEl.value;
              var isFileSelected = fileEl.hasAttribute("selected");
              data.files.push({
                filename: filename,
                selected: isFileSelected
              });
            }

            for (var index = 0; index < files.length; index++) {
              var textarea = files[index];
              var filename = files[index].getAttribute("filename");
              var selected = files[index].hasAttribute("selected");
              var targetEl = component.dom.querySelector("ul#files");

              // remove unnecessary indents
              var indent = textarea.value.split('\n').join('').match(/^\s*/)[0].length;
              var text = textarea.value.trim();
              var a = new RegExp("^\\s{" + indent + "}", "gm");
              text = text.replace(a, "");

              component.methods.createNewCodemirror(filename, selected, targetEl, text);
            }

            component.methods.renderResult();

            var cmInitCheck = setInterval(() => {
              var px = parseInt(component.dom.querySelector(".CodeMirror[selected=true] > div:first-child").style.left.replace("px", ""));
              if (px > 100) {
                component.editors["index.html"].refresh();
              }
              else {
                clearInterval(cmInitCheck);
              }
            }, 10);
          })
        }
      },
    }
  }
</script>