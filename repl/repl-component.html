<template>
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/codemirror@5.62.0/lib/codemirror.min.css" />
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/codemirror@5.62.0/addon/fold/foldgutter.css" />
	<header>
		<if data.props.title>
			<div class="inputContainer">
				<input class="title" value="{ data.props.title}" readonly onclick="methods.titleFocus(event);"
					oninput="methods.titleInput(event);" onchange="methods.titleRename(event);"
					onblur="methods.titleRename(event);">
				<div class="ghost-input">{ data.props.title}</div>
			</div>
		</if>
		<div class="buttons">
			<if data.props.download==true>
				<button onclick="methods.download()">Download</button>
			</if>
			<if data.props.save==true>
				<button onclick="methods.save()">Save</button>
			</if>
			<if data.props.fullscreen==true>
				<button onclick="methods.fullscreenToggle()">Fullscreen</button>
			</if>
		</div>
	</header>

	<div id="topArea">
		<div id="editor">
			<ul id="file-tabs">
				<each data.files as file>
					<li filename="{file.filename}" selected="{ file.selected }" onclick="methods.changeSelectedFile(event);">
						<div class="inputContainer">
							<input class="filename" value="{file.filename.replace('.html', '')}" readonly
								onclick="methods.focusFilename(event);" oninput="methods.inputFilename(event);"
								onchange="methods.renameFilename(event);" onblur="methods.blurFilename(event)">
							<div class="ghost-input">{file.filename.replace('.html', '')}</div>
						</div>
						<div class="extension">.html</div>
						<if data.props.crud==true>
							<div class="delete" onclick="methods.deleteFile(event)">âœ•</div>
						</if>
					</li>
				</each>
				<if data.props.crud==true>
					<li class="add" onclick="methods.addFile()">+</li>
				</if>
			</ul>

			<ul id="files" passive>
				<slot name="files"></slot>
			</ul>
		</div>
		<div class="v-resizer" onmousedown="methods.resize(event)"></div>
		<div id="result">
			<div id="result-header">
				Result
			</div>
			<if data.props.addressbar==true>
				<div id="addressbar">
					<!-- {data.urlHistory.length} - {data.currentUrlIndex} -->
					<button {(data.currentUrlIndex < 2) ? "disabled" : "" } onclick="methods.goBack(event);"></button>
					<button {(data.currentUrlIndex> data.urlHistory.length - 1) ? "disabled" : ""}
						onclick="goNext(event);"></button>
					<input type="text" value="{data.url}" id="url" onchange="methods.changeURL(event)">
				</div>
			</if>

			<iframe id="result" name="result" {(data.resize.x || data.resize.y) ? "resizing" : "" }></iframe>
		</div>
	</div>
	<if data.props.console==true>
		<div class="h-resizer" onmousedown="methods.resize(event)"></div>
		<div id="console">
			<label>CONSOLE <a onclick="methods.clearConsole(event)">Clear</a></label>
			<div class="messages">
				<ul>
					<each data.console as entry>
						<li class="{entry.method}">{entry.message} <if entry.file>(<span class="debugLink"
									onclick="methods.openFileGotoLine('{entry.file}', '{entry.line}','{entry.char}')">{entry.file}:{entry.line}:{entry.char}</span>)
							</if>
						</li>
					</each>
				</ul>
				<div><input placeholder=">_" name="consoleEntry" onkeyup="methods.sendJStoResult(event)"></div>
			</div>
		</div>
	</if>

</template>

<style>
	:host {
		display: flex;
		width: 1000px;
		height: 500px;
		border: 2px solid #dddddd;
		font-family: Arial, Helvetica, sans-serif;
		flex-direction: column;
		background-color: white;
		box-shadow: 0px 0px 25px rgb(0 0 0 / 10%);
		text-align: left;
		font-size: 13px;
		box-sizing: border-box;
		/* border-radius: 10px; */
		/* overflow: hidden; */
	}

	:host(.fullscreen) {
		position: fixed;
		width: 100%;

		left: 0;
		transform: translate(0, 0);
		max-width: unset;
		max-height: unset;
		top: 0;
	}

	header {
		background-color: #4197b9;
		color: white;
		height: 40px;
		display: flex;
		align-items: center;
		padding: 0px 10px;
		margin-left: -2px;
		width: calc(100% + 4px);
		box-sizing: border-box;
		margin-top: -2px;
		justify-content: space-between;
	}

	slot[name=files] {
		display: none;
	}

	#topArea {
		display: flex;
		/*
    height: calc(100% - 40px - "{data.topAreaHeight}");
    max-height: calc(100% - 30px);*/
		flex: 1;
		overflow: hidden;
	}

	#editor {
		display: flex;
		flex-direction: column;
		width: "{data.editorWidth}";
		min-width: 30%;
		max-width: 60%;
	}

	#result {
		display: flex;
		flex-direction: column;
		border-left: 2px solid #dddddd;
		box-sizing: border-box;
		flex: 1;
	}

	.v-resizer {
		cursor: ew-resize;
		width: 1px;
		position: relative;
	}

	.v-resizer:after {
		content: "";
		display: block;
		height: 100%;
		width: 8px;
		position: absolute;
		z-index: 10;
	}

	.h-resizer {
		cursor: ns-resize;
		height: 1px;
		width: 100%;
		position: relative;
	}

	.h-resizer:after {
		content: "";
		display: block;
		width: 100%;
		height: 8px;
		position: absolute;
		left: -2px;
		z-index: 10;
	}

	#console {
		border-top: 2px solid #dddddd;
		display: flex;
		flex-direction: column;
		position: relative;
		min-height: 30px;
		height: "{data.topAreaHeight}"
	}

	#console .messages {
		list-style: none;
		font-family: monospace;
		padding: 0;
		margin: 0px;
		overflow: auto;
		position: absolute;
		top: 35px;
		left: 0;
		right: 0;
		bottom: 0;
	}

	#console .messages ul {
		list-style: none;
		font-family: monospace;
		padding: 0;
		margin: 0px;
	}

	#console .messages li {
		border-color: #d4d4d4;
		border-style: solid;
		border-width: 1px 0px;
		padding: 3px 10px;
		margin-top: -1px;
		font-size: 12px;
	}

	#console .messages li.error {
		border-color: #fed6d7;
		background-color: #fff0f0;
		color: #fc0d1b;
	}

	#console .messages li.warn {
		border-color: #f3e5a7;
		background-color: #fffbe6;
		color: #5c3c08;
	}

	#console label {
		background-color: #f1f1f1;
		width: 100%;
		display: block;
		font-family: monospace;
		font-size: 14px;
		padding: 5px 10px;
		box-sizing: border-box;
		color: #666666;
		position: sticky;
		top: 0px;
	}

	input[name=consoleEntry] {
		font-family: monospace;
		border: none;
		padding: 5px 10px;
		font-size: 12px;
		outline: none;
		width: 100%;
		box-sizing: border-box;
	}

	#file-tabs {
		/* border-bottom: 2px solid #dddddd; */
		line-height: 35px;
		overflow: overlay;
		-webkit-background-clip: text;
		background-clip: text;
		background-color: rgba(0, 0, 0, 0);
		transition: background-color .8s;
		height: 35px;
		position: relative;
	}

	#file-tabs:before {
		content: "";
		width: 100%;
		position: absolute;
		background-color: #f1f1f1;
		height: 100%;
	}

	.CodeMirror-vscrollbar,
	.CodeMirror-hscrollbar {
		-webkit-background-clip: text;
		background-clip: text;
		background-color: rgba(0, 0, 0, 0);
		transition: background-color .8s;
	}

	#file-tabs::-webkit-scrollbar,
	.CodeMirror-hscrollbar::-webkit-scrollbar {
		width: 5px;
		height: 5px;
	}

	.CodeMirror-vscrollbar::-webkit-scrollbar {
		width: 10px;
	}

	.CodeMirror-hscrollbar::-webkit-scrollbar {
		height: 10px;
	}

	#file-tabs::-webkit-scrollbar-track,
	.CodeMirror-vscrollbar::-webkit-scrollbar-track,
	.CodeMirror-hscrollbar::-webkit-scrollbar-track {
		background-color: transparent;

	}

	#file-tabs::-webkit-scrollbar-thumb,
	.CodeMirror-vscrollbar::-webkit-scrollbar-thumb,
	.CodeMirror-hscrollbar::-webkit-scrollbar-thumb {
		background-color: rgb(206, 206, 206);
	}


	#file-tabs::-webkit-scrollbar-thumb,
	.CodeMirror-vscrollbar::-webkit-scrollbar-thumb,
	.CodeMirror-hscrollbar::-webkit-scrollbar-thumb {
		background-color: inherit;
	}

	#file-tabs:hover,
	.CodeMirror:hover .CodeMirror-vscrollbar,
	.CodeMirror:hover .CodeMirror-hscrollbar {
		background-color: rgb(206, 206, 206);
	}

	.CodeMirror-linenumber.CodeMirror-gutter-elt {
		transform: translateX(-20px);
	}

	.CodeMirror-lines {
		padding-left: 20px;
		padding-top: 20px;
		width: calc(100%);
	}

	.CodeMirror-scroll {
		margin-right: -25px;
	}

	#file-tabs li {
		position: relative;
		cursor: pointer;
		padding: 0px 10px 0px 15px;
		font-size: 14px;
		color: #888;
		white-space: nowrap;
		background-color: #f1f1f1;
		display: flex;
	}

	#file-tabs .add {
		font-size: 22px;
		padding: 0px 10px 0px 10px;
	}

	#file-tabs .delete {
		opacity: 0;
		pointer-events: none;
		transition: opacity 500ms;
		font-size: 12px;
		margin-left: 10px;
	}

	#file-tabs li[selected=true] .delete {
		opacity: 1;
		pointer-events: all;
		cursor: pointer;
	}

	#file-tabs li[selected=false]:hover .delete {
		opacity: 1;
		pointer-events: all;
	}

	#file-tabs li:first-child input {
		pointer-events: none;
	}

	#file-tabs li:first-child .delete {
		pointer-events: none;
		display: none;
	}


	#file-tabs li[selected=true] {
		cursor: default;
		background-color: white;
		color: #4197b9;
	}

	#file-tabs li.focus .delete {
		visibility: hidden;
		pointer-events: none;
		cursor: default;
	}

	#file-tabs li.focus .extension {
		color: #888888;
	}

	.inputContainer {
		position: relative;
	}

	input.filename {
		position: absolute;
		width: 100%;
		padding: 0;
		margin-top: 10px;
		border: none;
		cursor: pointer;
		outline: none;
		background-color: transparent;
		color: #888888;
	}

	#file-tabs li[selected=true] input.filename {
		cursor: text;
		color: #4197b9;
	}

	.ghost-input {
		font-size: 13.3333px;
		min-width: 3px;
	}

	input.title {
		position: absolute;
		width: 100%;
		padding: 0;
		outline: 0;
		border: none;
		font-size: 16px;
		background: none;
		color: white;
		z-index: 1;
		margin-top: -9px;
	}

	input.title+.ghost-input {
		font-size: 16px;
		z-index: 0;
		opacity: 0;
		height: 0px;
		padding-right: 50px;
	}

	/*
  #file-tabs li[selected=true]::after {
    content: "";
    position: absolute;
    width: 100%;
    height: 3px;
    background-color: #292;
    bottom: 0px;
    left: 0px;
  }
  */

	#result-header {
		border-bottom: 2px solid #dddddd;
		line-height: 35px;
		font-size: 14px;
		padding: 0px 15px;
	}

	#file-tabs,
	#files {
		display: flex;
		list-style: none;
		padding: 0px;
		margin: 0px;
	}

	#files {
		flex: 1;
		flex-direction: column;
		height: 0px;
	}

	.CodeMirror {
		height: 100%;
		width: 100%;
		display: none;
		line-height: 20px;
	}

	.CodeMirror[selected=true] {
		display: block;
	}

	#files textarea,
	iframe#result {
		width: 100%;
		height: 100%;
		border: none;
	}

	iframe#result[resizing] {
		pointer-events: none;
	}

	#addressbar {
		display: flex;
		align-items: center;
	}

	#addressbar button {
		background-size: contain;
		background-repeat: no-repeat;
		width: 17px;
		height: 17px;
		border: none;
		cursor: pointer;
	}

	#addressbar button:disabled {
		opacity: .4;
		cursor: default;
	}

	#addressbar button:nth-child(1) {
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'%3E%3Ctitle%3Eicon-arrow-left%3C/title%3E%3Cpolyline points='20.6 8 5.62 24.1 20.6 40.2' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/polyline%3E%3Cline x1='7.53' y1='24.1' x2='42.33' y2='24.1' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/line%3E%3C/svg%3E");
		margin-right: 10px;
	}

	#addressbar button:nth-child(2) {
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'%3E%3Ctitle%3Eicon-arrow-right%3C/title%3E%3Cpolyline points='27.35 40.2 42.33 24.1 27.35 8' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/polyline%3E%3Cline x1='40.42' y1='24.1' x2='5.62' y2='24.1' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/line%3E%3C/svg%3E");
	}

	div#addressbar {
		background-color: #f2f3f7;
		border-bottom: 1px solid #ced0dd;
		padding: 10px 10px;
	}

	input#url {
		flex: 1;
		border-radius: 3px;
		outline: none;
		box-shadow: none;
		border: 1px solid #ced0dd;
		padding: 0px 10px;
		line-height: 26px;
		font-size: 14px;
		margin-left: 10px;
		transition: all ease-in .1s;
	}

	input#url:focus {
		border: 1px solid #9ec5ef;
		box-shadow: 0 2px 8px 0 rgb(0 0 0 / 8%);
	}

	.debugLink {
		color: black;
		text-decoration: underline;
		cursor: pointer;
	}

	.activeline {
		position: relative;
		background-color: rgba(0, 0, 0, .04);
	}

	/* word wrap */
	.cke_reset_all .CodeMirror-scroll * {
		white-space: pre-wrap;
	}

	.CodeMirror-gutter-elt {
		position: absolute;
		cursor: default;
		z-index: 4;
		transform: translateX(-21px);
	}
</style>

<script>
	class {
		data = {
			files: [],
			url: "/",
			urlHistory: [
				"/"
			],
			currentUrlIndex: 1,
			console: [],
			resize: {
				x: false,
				y: false
			},
			editorWidth: "65%",
			topAreaHeight: "120px",
			URLShortening: {
				short: "https://typop.net/short/shorten/",
				redirect: "https://typop.net/short/redirect/?url="
			}
		}
		methods = {
			renderResult() {
				var indexContent = component.editors["index.html"].getValue();
				var files = component.methods.rewriteGet("index.html", indexContent);

				if (component.blobs) {
					for (let index = 0; index < Object.keys(component.blobs).length; index++) {
						let url = component.blobs[Object.keys(component.blobs)[index]].blobUrl;
						console.log(url);
						URL.revokeObjectURL(url);
					}
				}
				component.blobs = [];
				var blobs = component.blobs;

				for (let index = 0; index < Object.keys(files).length; index++) {
					var file = files[Object.keys(files).reverse()[index]];

					for (const filename in file) {
						if (blobs[filename] == undefined) {
							var newContent = file["content"];
							var m;
							var regex = /(?<!\/\/(\s+)?)get\((\s+)?(\[)?([\s\S]*?)?(\,)?(\s+)?\]?(\s+)?\)(\;)?/gm;

							while ((m = regex.exec(file["content"])) !== null) {
								// This is necessary to avoid infinite loops with zero-width matches
								if (m.index === regex.lastIndex) {
									regex.lastIndex++;
								}
								if (m[3]) { // multi
									var filenames = m[4].replace(/((\\n)|[\\\s\"\[\]])/g, "");
									var filenames = filenames.split(",");
									var get = m[0];
									var newGet = "";
									for (let i = 0; i < filenames.length; i++) {
										var fn = filenames[i].replace(/\'\"/g, '');;
										newGet += "get('" + blobs[fn].blobUrl + "', '" + fn + "');";
									}
									newContent = newContent.replace(get, newGet);
								}
								else if (m[4].indexOf(",") > -1) { // custom name
									var fileAndCustomName = m[4].replace(/((\\n)|[\\\s\"\[\]])/g, "").split(",");
									var fn = fileAndCustomName[0]
									var cn = fileAndCustomName[1] + ".html";
									var get = m[0];
									var newGet = "get('" + blobs[fn].blobUrl + "', '" + cn + "');";
									newContent = newContent.replace(get, newGet);
								}
								else { // single
									var fn = m[4].slice(0, -1).replace(/((\\n)|[\\\s\"\[\]])/g, "");;
									var get = m[0];
									var newGet = "get('" + blobs[fn].blobUrl + "', '" + fn + "');";
									newContent = newContent.replace(get, newGet);
								}
							}

							var blob = new Blob([newContent], { type: "text/html; charset=utf-8" });
							var blobUrl = URL.createObjectURL(blob);

							if (document.location.host == "root") {// dev env
								newContent = newContent.replace("https://simply.js.org/simply.min.js", "//root/simply/simply.min.js");
							}
							blobs[file["filename"]] = {
								filename: file["filename"],
								blobUrl: blobUrl,
								content: newContent
							};
						}
					}
				}
				var runInResult = "<script>function " + component.methods.runInResult.toString() + "runInResult();<\/script>";
				var base = "<head><base href='" + document.location.href + "'>";

				blobs["index.html"].content = blobs["index.html"].content.replace("<head>", base) + runInResult;
				dom.querySelector("iframe").setAttribute("src", "about:blank");
				//dom.querySelector("iframe#result").setAttribute("srcdoc", "");

				dom.querySelector("iframe#result").addEventListener("load", function bas() {
					dom.querySelector("iframe#result").removeEventListener("load", bas);
					dom.querySelector("iframe").removeAttribute("src");
					data.urlHistory = [data.urlHistory[0]];
					data.url = data.urlHistory[0];
					data.currentUrlIndex = 1;
					data.console = [];

					setTimeout(function () {
						dom.querySelector("iframe#result").contentWindow.document.write(blobs["index.html"].content);
					}, 0);
				});
			},
			rewriteGet(filename, content) {
				var regex = /(?<!\/\/(\s+)?)get\((\s+)?(\[)?([\s\S]*?)?(\,)?(\s+)?\]?(\s+)?\)(\;)?/gm;
				var regex2 = /(?<!\/\/(\s+)?)get\((\s+)?(\[)?([\s\S]*?)?(\,)?(\s+)?\]?(\s+)?\)(\;)?/gm;
				var blobs = "";
				let m;
				let mm;

				if (!component.files) {
					component.files = [];
				}

				if (!component.files[i]) {
					component.files[filename] = {};
				}

				while ((m = regex.exec(content)) !== null) {
					// This is necessary to avoid infinite loops with zero-width matches
					if (m.index === regex.lastIndex) {
						regex.lastIndex++;
					}
					if (m[3]) {
						var f = m[4].replace(/((\\n)|[\\\s\"\[\]])/g, "");
						var fns = f.split(",");
						for (let i = 0; i < fns.length; i++) {
							const fn = fns[i].replace(/\'\"/g, '');
							var nestedComponentContent = component.editors[fn].getValue();

							while ((mm = regex2.exec(content)) !== null) {
								var nnestedComponentContent = component.editors[fn].getValue();;
								component.methods.rewriteGet(fn, nnestedComponentContent);
							}
						}
					}
					else if (m[4].indexOf(",") > -1) { // custom name
						var fn = m[4].replace(/((\\n)|[\\\s\"\[\]])/g, "").split(",")[0];

						var nestedComponentContent = component.editors[fn].getValue();

						while ((mm = regex2.exec(content)) !== null) {
							var nnestedComponentContent = component.editors[fn].getValue();;
							component.methods.rewriteGet(fn, nnestedComponentContent);
						}
					}
					else {
						var fn = m[4].slice(0, -1).replace(/((\\n)|[\\\s\"\[\]])/g, "");
						var nestedComponentContent = component.editors[fn].getValue();

						while ((mm = regex2.exec(content)) !== null) {
							var nnestedComponentContent = component.editors[fn].getValue();;
							component.methods.rewriteGet(fn, nnestedComponentContent);
						}
					}
				}

				component.files[filename]["content"] = content;
				component.files[filename]["filename"] = filename;
				return component.files;
			},
			changeSelectedFile(event) {
				event.preventDefault();
				event.stopPropagation();
				var filename = event.currentTarget.getAttribute("filename");
				var filenameSelector = filename.replace(/\./g, "\\.");

				for (let i = 0; i < data.files.length; i++) {
					var fn = data.files[i]["filename"];
					if (filename == fn) {
						data.files[i]["selected"] = true;
					}
					else {
						data.files[i]["selected"] = false;
					}
				}

				var targetFile = dom.querySelector("#files .CodeMirror[selected=true]");
				var fileItself = dom.querySelector("#files .CodeMirror[filename='" + filenameSelector + "']");

				targetFile.setAttribute("selected", false);
				fileItself.setAttribute("selected", true);

				component.editors[filename].refresh();
				component.editors[filename].focus();

			},
			runInResult() {
				window.addEventListener('message', (event) => {
					if (event.data.action == "consoleEnter") {
						eval("console.log(" + JSON.stringify(event.data.code) + ");//@ sourceURL=console");

						if (event.data.code.indexOf("console") !== 0) {
							try {
								if (JSON.parse(event.data.code)) {
									var type = "";
									if (Array.isArray(JSON.parse(event.data.code))) {
										var type = "Array: ";
									}
									else if (typeof JSON.parse(event.data.code) == "object") {
										var type = "Object: "
									}

									eval("console.log('" + type + "' + " + JSON.stringify(event.data.code) + ");//@ sourceURL=console");
								}
							} catch (error) {
								if (typeof eval(event.data.code) == "object") {
									var type = eval(event.data.code) instanceof Element ? "[HTMLElement]" : "[Object]";

									eval("console.log('" + type + "');//@ sourceURL=console");
								}
								else {
									console.log(event.data.code);
									eval("console.log(" + event.data.code + ");//@ sourceURL=console");
								}
							}
						}
						else {
							eval(event.data.code + "//@ sourceURL=console");
						}
					}
					else if (event.data.action = "go") {
						console.log(`Received message from parent: ${event.data.url}`);
						window.frameElement.contentWindow.Router.go(event.data.url);
					}
				});

				window.addEventListener('popstate', function (event) {
					window.parent.postMessage({
						action: "urlChange",
						url: "/" + router.location.pathname
					}, event);
				});

				(function (w) {
					"use strict";

					var A, F, O, consoleMethods, fixConsoleMethod, consoleOn,
						allHandlers, methodObj;

					A = [];
					F = function () { return; };
					O = {};

					// All possible standard methods to provide an interface for
					consoleMethods = [
						"assert", "clear", "count", "debug",
						"dir", "dirxml", "error", "exception",
						"group", "groupCollapsed", "groupEnd",
						"info", "log", "profile", "profileEnd",
						"table", "time", "timeEnd", "timeStamp",
						"trace", "warn"
					];

					// Holds handlers to be executed for every method
					allHandlers = [];

					// Holds handlers per method
					methodObj = {};

					// Overrides the existing console methods, to call any stored handlers first
					fixConsoleMethod = (function () {
						var func, empty;

						empty = function () {
							return F;
						};

						if (w.console) {
							// If `console` is even available
							func = function (methodName) {
								var old;
								if (methodName in console && (old = console[methodName])) {
									// Checks to see if `methodName` is defined on `console` and has valid function to execute
									// (and stores the old handler)
									// This is important so that undefined methods aren't filled in
									console[methodName] = function () {
										// Overwrites current console method with this function
										var args, argsForAll, i, j;
										// Copy all arguments passed to handler
										args = A.slice.call(arguments, 0);
										for (i = 0, j = methodObj[methodName].handlers.length; i < j; i++) {
											// Loop over all stored handlers for this specific method and call them
											F.apply.call(methodObj[methodName].handlers[i], console, args);
										}
										for (i = 0, j = allHandlers.length; i < j; i++) {
											// Loop over all stored handlers for ALL events and call them
											argsForAll = [methodName];
											A.push.apply(argsForAll, args);


											var file = new Error().stack.split("\n")[2].split("(");

											if (typeof file[1] == undefined) {
												file = file[1].split(":");
												console.file = file[0];
												console.line = file[1];
												console.char = file[2].slice(0, -1);
											}



											F.apply.call(allHandlers[i], console, argsForAll);
										}
										// Calls old
										F.apply.call(old, console, args);
									};

								}
								return console[methodName] || empty;
							};
						} else {
							func = empty;
						}

						return func;
					}());

					// Loop through all standard console methods and add a wrapper function that calls stored handlers
					(function () {
						var i, j, cur;
						for (i = 0, j = consoleMethods.length; i < j; i++) {
							// Loop through all valid console methods
							cur = consoleMethods[i];
							methodObj[cur] = {
								handlers: []
							};
							fixConsoleMethod(cur);
						}
					}());

					// Main handler exposed
					consoleOn = function (methodName, callback) {
						var key, cur;
						if (O.toString.call(methodName) === "[object Object]") {
							// Object literal provided as first argument
							for (key in methodName) {
								// Loop through all keys in object literal
								cur = methodName[key];
								if (key === "all") {
									// If targeting all events
									allHandlers.push(cur);
								} else if (key in methodObj) {
									// If targeting specific valid event
									methodObj[key].handlers.push(cur);
								}
							}
						} else if (typeof methodName === "function") {
							// Function provided as first argument
							allHandlers.push(methodName);
						} else if (methodName in methodObj) {
							// Valid String event provided
							methodObj[methodName].handlers.push(callback);
						}
					};

					// Actually expose an interface
					w.ConsoleListener = {
						on: consoleOn
					};
				}(this));

				ConsoleListener.on(function (methodName, message) {
					try {
						if (typeof eval(message) == "object") {
							if (message instanceof ShadowRoot) {
								message = "[ShadowRoot]"
							}
							else if (message instanceof Window) {
								message = "[Window]"
							}
							else if (message instanceof Document) {
								message = "[Document]"
							}
							else if (eval(message) instanceof Element) {
								message = "[HTMLElement] " + message.tagName
							}
							else {
								// normal obj ise
								try {
									message = JSON.stringify(message);
								} catch (e) {
									// circular obj ise
									const getCircularReplacer = () => {
										const seen = new WeakSet();
										return (key, value) => {
											if (typeof value === "object" && value !== null) {
												if (seen.has(value)) {
													return;
												}
												seen.add(value);
											}
											if (key !== "__o_" && key !== "__c_" && key !== "__p_" && key !== "__r_") {
												return value;
											}
										};
									};
									message = JSON.stringify(message, getCircularReplacer());
								}
							}
						}
					} catch (error) { }

					self = this;
					window.parent.postMessage({
						action: "console",
						method: methodName,
						message: message,
						file: self.file,
						line: self.line,
						char: self.char
					}, event);
				});

				window.onerror = function (error, file, line, char) {
					if (file !== "console") {
						var file = file;
						var line = line;
						var char = char;
					}

					window.parent.postMessage({
						action: "console",
						method: "error",
						message: error,
						file,
						line,
						char
					}, event);
				};
			},
			changeURL(event) {
				var result = dom.querySelector("iframe#result").contentWindow;
				if (event.target) {
					var url = event.target.value;
					event.target.blur();
				}
				else {
					var url = event;
				}
				result.postMessage({
					action: "go",
					url: document.location.pathname + url.replace(/^\//, '')
				});
			},
			goBack(event) {
				data.currentUrlIndex -= 1;
				var url = data.urlHistory[data.currentUrlIndex - 1];
				component.methods.changeURL(url);
			},
			goNext(event) {
				data.currentUrlIndex += 1;
				var url = data.urlHistory[data.currentUrlIndex - 1];
				component.methods.changeURL(url);
			},
			sendJStoResult(event) {
				if (event.which == 13) {
					var result = dom.querySelector("iframe#result").contentWindow;
					var code = event.target.value;
					event.target.value = "";
					result.postMessage({ action: "consoleEnter", code: code });
					dom.querySelector("input[name=consoleEntry]").focus();
				}
			},
			clearConsole(e) {
				data.console = [];
			},
			resize(e) {

				var direction = e.target.className == "v-resizer" ? "v" : "h";
				if (direction == "v") {
					data.resize.x = true;
				}
				else {
					data.resize.y = true;
				}

				e.preventDefault();
				dom.addEventListener("mousemove", function (me) {
					if (!data.resize.x && !data.resize.y) {
						return;
					}
					me.preventDefault();
					var containerWidth = dom.getRootNode().host.offsetWidth;
					var containerHeight = dom.getRootNode().host.offsetHeight;

					if (data.resize.x) {
						var offsetRight = containerWidth - (me.clientX - dom.getRootNode().host.getBoundingClientRect().left);
						var birim = containerWidth / 100;
						offsetRight = 100 - (offsetRight / birim);
						data.editorWidth = offsetRight + "%";
					}
					else {
						var offsetTop = containerHeight - (me.clientY - dom.getRootNode().host.getBoundingClientRect().top);
						data.topAreaHeight = Math.abs(offsetTop) + "px";
					}
				});
				document.addEventListener("mouseup", function (e) {
					e.preventDefault();
					data.resize.x = false;
					data.resize.y = false;
				});

			},
			openFileGotoLine(filename, line, char) {
				for (let i = 0; i < data.files.length; i++) {
					const file = data.files[i];
					if (file.filename == filename) {
						file.selected = true;
					}
					else {
						file.selected = false;
					}
				}
				var filenameSelector = filename.replace(/\./g, "\\.");

				var targetFile = dom.querySelector("#files .CodeMirror[selected=true]");
				var fileItself = dom.querySelector("#files .CodeMirror[filename='" + filenameSelector + "']");

				targetFile.setAttribute("selected", false);
				fileItself.setAttribute("selected", true);

				component.editors[filename].setCursor(line - 1, char - 1);
				component.editors[filename].refresh();
				component.editors[filename].focus();
			},
			focusFilename(e) {
				if (data.props.crud == true) {
					var selected = e.target.parentElement.parentElement.getAttribute("selected");
					if (selected == "true") {
						e.stopPropagation();
						e.target.readOnly = false;
						e.target.parentElement.parentElement.classList.add("focus");
						e.target.focus();
					}
				}
			},
			inputFilename(e) {
				var ghost = e.target.parentElement.parentElement.querySelector(".ghost-input");
				ghost.innerHTML = e.target.value;
			},
			renameFilename(e) {
				var oldName = e.target.parentElement.parentElement.getAttribute("filename");
				var newName = e.target.value;
				if (newName !== "" && !component.editors[newName + ".html"]) {
					console.log("hem boÅŸ deÄŸil hem duplicate deÄŸil");
					for (let i = 0; i < data.files.length; i++) {
						const file = data.files[i];
						if (file.filename == oldName) {
							newName += ".html";
							file.filename = newName;
							component.editors[newName] = component.editors[oldName];
							delete component.editors[oldName];
							dom.querySelector(".CodeMirror[filename='" + oldName + "']").setAttribute("filename", newName);
							console.log(component.editors[newName]);
						}
					}
					component.methods.renderResult();
				}
				else {
					console.log("boÅŸ ya da duplicate");
					if (oldName !== e.target.focus()) {
						e.target.focus();
						return false;
					}
				}
			},
			blurFilename(e) {
				var selected = e.target.parentElement.parentElement.getAttribute("selected");

				if (selected == "true") {
					e.stopPropagation();
					e.target.parentElement.parentElement.classList.remove("focus");
				}
			},
			deleteFile(e) {
				e.stopPropagation();
				var filename = e.target.parentElement.getAttribute("filename");

				if (confirm('Delete ' + filename + '?')) {
					component.editors[filename].setOption("mode", "text/x-csrc");
					component.editors[filename].getWrapperElement().remove();
					delete component.editors[filename];

					console.time();
					for (let i = 0; i < data.files.length; i++) {
						const file = data.files[i];
						if (file.filename == filename) {
							console.log(data.files, i);
							delete data.files[i];
							data.files = data.files.filter(Boolean);
							console.timeEnd();
							filename = data.files[i - 1].filename;
							var filenameSelector = filename.replace(/\./g, "\\.");
							var targetFile = dom.querySelector("#files .CodeMirror[selected=true]");
							if (!targetFile) {
								data.files[i - 1].selected = true;
								var fileItself = dom.querySelector("#files .CodeMirror[filename='" + filenameSelector + "']");
								fileItself.setAttribute("selected", true);
							}
							break;
						}
					}
					component.methods.renderResult();
					return false;
				} else {
					return false;
				}


			},
			addFile() {
				var i = 1;
				var filename = "component-" + i + ".html";
				while (component.editors["component-" + i + ".html"]) {
					i = i + 1;
				}
				filename = "component-" + i + ".html";
				for (let i = 0; i < data.files.length; i++) {
					const file = data.files[i];
					file.selected = false;
				}
				data.files.push({ "filename": filename, "selected": true });

				var fileTabs = dom.querySelector("#file-tabs");
				fileTabs.scrollLeft = fileTabs.scrollWidth;

				var template = "<template>\n\n</template>\n\n<style>\n::host {\n\n}\n</style>\n\n<script>\nclass \{\n\n\}\n<\/script>";

				var target = dom.querySelector("ul#files");
				component.methods.createNewCodemirror(filename, true, target, template);

				dom.querySelector("#files .CodeMirror[selected=true]").setAttribute("selected", false);
				//component.editors[filename].setCursor({ line: 1, ch: 0 });
				component.files[filename] = {
					filename: filename,
					content: template
				}
				setTimeout(() => {
					var filenameInput = dom.querySelector("li[filename=" + filename.replace(/\./g, "\\.") + "] input");
					filenameInput.click();

					filenameInput.setSelectionRange(0, filenameInput.value.length);
				}, 0);

				console.log(component.files);
			},
			createNewCodemirror(filename, selected, targetEl, text) {
				var autofocus = data.props.focus ? true : false;

				component.editors[filename] = CodeMirror(function (node) {
					node.setAttribute("filename", filename);
					node.setAttribute("selected", selected);
					targetEl.appendChild(node, targetEl);
				}, {
					value: text,
					autoRefresh: { delay: 0 },
					lineNumbers: true,
					gutter: true,
					smartIndent: true,
					autofocus: autofocus,
					mode: "htmlmixed",
					theme: 'default', // ambiance, ayu-mirage, cobalt, dracula, material, rubyblue, nord
					styleActiveLine: true,
					lineWrapping: true,
					foldGutter: true,
					gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"]
				});
				var render;
				component.editors[filename].on("changes", function (a, b, c, d) {
					try {
						clearTimeout(render);
					} catch (error) { }

					render = setTimeout(function () {
						component.methods.renderResult();
					}, 1000); // How long do you want the delay to be (in milliseconds)?
				});

				var currentHandle = null, currentLine;
				component.editors[filename].on("cursorActivity", highlight);
				component.editors[filename].on("focus", highlight);

				function highlight(cm) {
					var line = cm.getCursor().line;
					var handle = cm.getLineHandle(line);

					if (currentHandle) {
						cm.removeLineClass(currentHandle, "wrap", "activeline");
					}
					currentHandle = handle;
					currentLine = line;
					cm.addLineClass(currentHandle, null, "activeline");
				}
			},
			fullscreenToggle() {
				if (dom.getRootNode().host.className.indexOf("fullscreen") > -1) {
					dom.getRootNode().host.classList.remove("fullscreen");
				}
				else {
					dom.getRootNode().host.classList.add("fullscreen");
				}

			},
			titleFocus(e) {
				if (data.props.crud) {
					e.stopPropagation();
					e.target.readOnly = false;
					e.target.focus();
				}

			},
			titleInput(e) {
				var ghost = e.target.parentElement.querySelector(".ghost-input");
				ghost.innerHTML = e.target.value;
			},
			titleRename(e) {
				if (e.target.value.length !== 0) {
					data.props.title = e.target.value;
					e.target.blur();
				}
				else {
					e.target.focus();
				}

				console.log("yeah");
			},
			download() {
				var license = 'MIT License \n\
Copyright (c) '+ new Date().getFullYear() + ' simply.js \n\
\n\
Permission is hereby granted, free of charge, to any person obtaining a copy\n\
of this software and associated documentation files (the "Software"), to deal\n\
in the Software without restriction, including without limitation the rights\n\
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\
copies of the Software, and to permit persons to whom the Software is\n\
furnished to do so, subject to the following conditions:\n\
\n\
The above copyright notice and this permission notice shall be included in all\n\
copies or substantial portions of the Software.\n\
\n\
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\
SOFTWARE.';
				var zip = new JSZip();
				//zip.file("Hello.txt", "Hello World\n");
				//var img = zip.folder("images");
				//img.file("smile.gif", imgData, { base64: true });
				for (let i = 0; i < data.files.length; i++) {
					var filename = data.files[i].filename;
					var editor = component.editors[filename];
					var content = editor.getValue();
					zip.file(filename, content);
					zip.file("LICENSE", license)
					zip.file("README.md", "Welcome to simply.js");
				}
				zip.generateAsync({ type: "blob" }).then(function (content) {
					// see FileSaver.js
					saveAs(content, data.props.title + ".zip");
				});
			},
			save() {
				console.log("save", component.editors);
				var project = {
					title: data.props.title,
					files: []
				};
				for (var i = 0; i < data.files.length; i++) {
					var file = data.files[i];
					var filename = file.filename;
					var content = component.editors[filename].getValue();
					var selected = file.selected
					project.files.push({ filename, content, selected });
				}

				var d = new FormData();
				// https://developer.mozilla.org/en-US/docs/Glossary/Base64
				var url = btoa(unescape(encodeURIComponent(JSON.stringify(project))));

				d.append("longurl", url);
				var xhr = new XMLHttpRequest();
				xhr.withCredentials = true;
				xhr.addEventListener("readystatechange", function () {
					if (this.readyState === 4) {
						var id = this.responseText;
						if (document.location.hash.indexOf("?") > -1) {
							var hash = document.location.hash.split("?")[0];
						}
						else {
							var hash = document.location.hash;
						}

						window.history.pushState('', '', document.location.origin + document.location.pathname + hash + "?" + id);
					}
				});

				xhr.open("POST", data.URLShortening.short);
				xhr.send(d);
			},
			init() {

				var slot = dom.querySelector('slot[name=files]');
				component.editors = [];

				if ((location.hash.length > 1 && location.hash.indexOf("?") > -1) || data.props.id) {

					if (location.hash.split("?")[1] !== undefined) {
						var id = location.hash.split("?")[1];
					}
					else if (data.props.id) {
						var id = data.props.id;
					}


					var xhr = new XMLHttpRequest();
					xhr.withCredentials = true;
					xhr.open("GET", data.URLShortening.redirect + id, true);
					xhr.send();
					xhr.addEventListener("readystatechange", function () {
						if (this.readyState === 4) {
							var project = JSON.parse(decodeURIComponent(escape(atob(this.responseText))));

							var targetEl = dom.querySelector("ul#files");

							for (var i = 0; i < project.files.length; i++) {
								var file = project.files[i];
								data.files.push({
									filename: file.filename,
									selected: file.selected
								});
								component.methods.createNewCodemirror(file.filename, file.selected, targetEl, file.content);
							}
							data.props.title = project.title;

							component.methods.renderResult();
						}
					});
				}

				else if (slot.assignedNodes()[0]) {
					var files = slot.assignedNodes()[0].querySelectorAll("textarea");
					for (let index = 0; index < files.length; index++) {
						var fileEl = files[index];
						var filename = fileEl.getAttribute("filename");
						var fileContent = fileEl.value;
						var isFileSelected = fileEl.hasAttribute("selected");
						data.files.push({
							filename: filename,
							selected: isFileSelected
						});
					}

					for (var index = 0; index < files.length; index++) {
						var textarea = files[index];
						var filename = files[index].getAttribute("filename");
						var selected = files[index].hasAttribute("selected");
						var targetEl = dom.querySelector("ul#files");

						// remove unnecessary indents
						var indent = textarea.value.split('\n').join('').match(/^\s*/)[0].length;
						var text = textarea.value.trim();
						var a = new RegExp("^\ {" + indent + "}", "gm");
						text = text.replace(a, "");

						component.methods.createNewCodemirror(filename, selected, targetEl, text);
					}
					component.methods.renderResult();
				}

				var cmInitCheck = setInterval(() => {
					var px = 0;
					try {
						var px = parseInt(dom.querySelector(".CodeMirror[selected=true] > div:first-child").style.left.replace("px", ""));
					} catch (error) { }

					if (px > 100) {
						component.editors["index.html"].refresh();
					}
					else {
						clearInterval(cmInitCheck);
					}
				}, 10);
			}
		}
		lifecycle = {
			beforeConstruct() {

			},
			afterFirstRender() {
				window.onerror = function (error, file, line, char) {
					data.console = [];
					data.console.push({
						method: "error",
						message: error
					});
				};
				// listen messages from child
				window.addEventListener('message', (event) => {
					if (event.data.action == "urlChange") {
						data.url = event.data.url.replace(document.location.pathname, "");
						if (data.url !== data.urlHistory[data.currentUrlIndex - 1]) {
							data.urlHistory = data.urlHistory.slice(0, data.currentUrlIndex);
							data.urlHistory.push(data.url);
							data.currentUrlIndex += 1;
						};
					}
					else if (event.data.action == "console") {
						if (component.editors[event.data.file]) {
							var file = event.data.file;
							var line = event.data.line;
							var char = event.data.char;
						}
						data.console.push({
							method: event.data.method,
							message: event.data.message,
							file,
							line,
							char
						});
						var messages = dom.querySelector("#console .messages");
						if (messages) {
							messages.scrollTop = messages.scrollHeight;
						}
					}
				});

				if (typeof CodeMirror == "undefined") {
					loadJS("https://cdn.jsdelivr.net/combine/npm/codemirror@5.62.0/lib/codemirror.min.js,npm/codemirror@5.62.0/mode/javascript/javascript.min.js,npm/codemirror@5.62.0/mode/css/css.min.js,npm/codemirror@5.62.0/mode/xml/xml.min.js,npm/codemirror@5.62.0/mode/htmlmixed/htmlmixed.min.js,npm/codemirror@5.62.0/addon/fold/foldcode.js,npm/codemirror@5.62.0/addon/fold/foldgutter.js,npm/codemirror@5.62.0/addon/fold/xml-fold.js,npm/codemirror@5.62.0/addon/fold/brace-fold.js,npm/codemirror@5.62.0/addon/fold/comment-fold.js,npm/codemirror@5.62.0/addon/fold/indent-fold.js,npm/codemirror-formatting@1.0.0/formatting.min.js,npm/jszip@3.1.5/dist/jszip.min.js,npm/filesaver.js@1.3.4/FileSaver.min.js", function () {
						methods.init();
					})
				}
				else {
					methods.init();
					// :)
				}
			},

		}
		watch(name, value, old, parents) { }
	}
</script>