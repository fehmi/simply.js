<template>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/codemirror@5.62.0/lib/codemirror.min.css" />

  <div id="editor">
    <ul id="file-tabs">
      <each data.files as file>
        <li filename="{file.filename}" selected="{ file.selected }" onclick="changeSelectedFile(event)">{file.filename}
        </li>
      </each>
      <li class="add" onclick="addFile()">+</li>
    </ul>

    <ul id="files" passive>
      <slot name="files"></slot>
    </ul>
  </div>

  <div id="result">
    <div id="result-header">
      Result
    </div>
    <div id="addressbar">
      <!-- {data.urlHistory.length} - {data.currentUrlIndex} -->
      <button {(data.currentUrlIndex < 2) ? "disabled" : "" } onclick="goBack(event);"></button>
      <button {(data.currentUrlIndex> data.urlHistory.length - 1) ? "disabled" : ""}
        onclick="goNext(event);"></button>
      <input type="text" value="{data.url}" id="url" onchange="changeURL(event)">
    </div>
    <iframe id="result" name="result"></iframe>
    <div id="console"></div>
  </div>

  <div id="console">

  </div>
</template>

<style>
  :host {
    display: flex;
    width: 960px;
    height: 450px;
    border: 2px solid #dddddd;
    font-family: Arial, Helvetica, sans-serif;
  }

  slot[name=files] {
    display: none;
  }

  #editor {
    display: flex;
    flex-direction: column;
    width: 65%;
  }

  #result {
    width: 35%;
    display: flex;
    flex-direction: column;
    border-left: 2px solid #dddddd;
  }

  #file-tabs {
    /* border-bottom: 2px solid #dddddd; */
    line-height: 35px;
    overflow: overlay;
    -webkit-background-clip: text;
    background-clip: text;
    background-color: rgba(0, 0, 0, 0);
    transition: background-color .8s;
  }

  #file-tabs::-webkit-scrollbar,
  .CodeMirror-vscrollbar::-webkit-scrollbar,
  .CodeMirror-hscrollbar::-webkit-scrollbar {
    width: 5px;
    height: 5px;
  }

  #file-tabs::-webkit-scrollbar-track,
  .CodeMirror-vscrollbar::-webkit-scrollbar-track,
  .CodeMirror-hscrollbar::-webkit-scrollbar-track {
    background-color: transparent;

  }

  #file-tabs::-webkit-scrollbar-thumb,
  .CodeMirror-vscrollbar::-webkit-scrollbar-thumb,
  .CodeMirror-hscrollbar::-webkit-scrollbar-thumb {
    background-color: #666;
  }

  #file-tabs::-webkit-scrollbar-thumb {
    background-color: inherit;
  }

  #file-tabs:hover {
    background-color: rgb(206, 206, 206);
  }

  #file-tabs li {
    position: relative;
    cursor: pointer;
    padding: 0px 15px;
    font-size: 14px;
    color: #888;
    white-space: nowrap;
    background-color: #f1f1f1;
  }

  #file-tabs .add {
    font-size: 22px;
    padding: 0px 10px 0px 5px;
  }

  #file-tabs li[selected=true] {
    cursor: default;
    pointer-events: none;
    background-color: white;
    color: #292;
  }

  /*
  #file-tabs li[selected=true]::after {
    content: "";
    position: absolute;
    width: 100%;
    height: 3px;
    background-color: #292;
    bottom: 0px;
    left: 0px;
  }
  */

  #result-header {
    border-bottom: 2px solid #dddddd;
    line-height: 35px;
    font-size: 14px;
    padding: 0px 15px;
  }

  #file-tabs,
  #files {
    display: flex;
    list-style: none;
    padding: 0px;
    margin: 0px;
  }

  #files {
    flex: 1;
    flex-direction: column;
    height: 100px;
  }

  .CodeMirror {
    height: 100%;
    width: 100%;
    display: none;
    line-height: 20px;
  }

  .CodeMirror[selected=true] {
    display: block;
  }

  #files textarea,
  iframe#result {
    width: 100%;
    height: 100%;
    border: none;
  }

  #addressbar {
    display: flex;
    align-items: center;
  }

  #addressbar button {
    background-size: contain;
    background-repeat: no-repeat;
    width: 17px;
    height: 17px;
    border: none;
    cursor: pointer;
  }

  #addressbar button:disabled {
    opacity: .4;
    cursor: default;
  }

  #addressbar button:nth-child(1) {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'%3E%3Ctitle%3Eicon-arrow-left%3C/title%3E%3Cpolyline points='20.6 8 5.62 24.1 20.6 40.2' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/polyline%3E%3Cline x1='7.53' y1='24.1' x2='42.33' y2='24.1' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/line%3E%3C/svg%3E");
    margin-right: 10px;
  }

  #addressbar button:nth-child(2) {
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'%3E%3Ctitle%3Eicon-arrow-right%3C/title%3E%3Cpolyline points='27.35 40.2 42.33 24.1 27.35 8' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/polyline%3E%3Cline x1='40.42' y1='24.1' x2='5.62' y2='24.1' fill='none' stroke='%23686f75' stroke-linecap='round' stroke-miterlimit='10' stroke-width='6'%3E%3C/line%3E%3C/svg%3E");
  }

  div#addressbar {
    background-color: #f2f3f7;
    border-bottom: 1px solid #ced0dd;
    padding: 10px 10px;
  }

  input#url {
    flex: 1;
    border-radius: 3px;
    outline: none;
    box-shadow: none;
    border: 1px solid #ced0dd;
    padding: 0px 10px;
    line-height: 26px;
    font-size: 14px;
    margin-left: 10px;
    transition: all ease-in .1s;
  }

  input#url:focus {
    border: 1px solid #9ec5ef;
    box-shadow: 0 2px 8px 0 rgb(0 0 0 / 8%);
  }
</style>

<script>
  class {
    data = {
      files: [],
      url: "/",
      urlHistory: [
        "/"
      ],
      currentUrlIndex: 1,
      console: [{
        method: "log",
        message: "Welcome to simply.js",
      }]
    }
    methods = {
      renderResult() {
        var indexContent = component.editors["index.html"].getValue();
        var files = component.methods.rewriteGet("index.html", indexContent);
        var blobs = [];

        for (let index = 0; index < Object.keys(files).length; index++) {
          var file = files[Object.keys(files).reverse()[index]];

          for (const filename in file) {
            if (blobs[filename] == undefined) {
              var newContent = file["content"];
              var m;
              var regex = /(?<!\/\/(\s+)?)get\((\[)?([\s\S]*?)?(.*)\)(\;)?/gm;

              while ((m = regex.exec(file["content"])) !== null) {
                // This is necessary to avoid infinite loops with zero-width matches
                if (m.index === regex.lastIndex) {
                  regex.lastIndex++;
                }

                if (m[3].indexOf(",") > -1) { // multi
                  var filenames = m[3].replace(/((\\n)|[\\\s\"\[\]])/g, "");
                  var filenames = filenames.split(",");
                  var get = m[0];
                  var newGet = "";
                  for (let i = 0; i < filenames.length; i++) {
                    var fn = filenames[i].replace(/\'\"/g, '');;
                    newGet += "get('" + blobs[fn].blobUrl + "', '" + fn + "');";
                  }
                  newContent = newContent.replace(get, newGet);
                }
                else {
                  var fn = m[4].slice(0, -1);
                  var get = m[0];
                  var newGet = "get('" + blobs[fn].blobUrl + "', '" + fn + "');";
                  newContent = newContent.replace(get, newGet);
                }
              }

              var blob = new Blob([newContent], { type: "text/html; charset=utf-8" });
              var blobUrl = URL.createObjectURL(blob);
              blobs[file["filename"]] = {
                filename: file["filename"],
                blobUrl: blobUrl,
                content: newContent
              };
            }
          }
        }
        var runInResult = "<script>function " + component.methods.runInResult.toString() + "runInResult();<\/script>";
        var base = "<head><base href=" + document.location.href + ">";
        blobs["index.html"].content = blobs["index.html"].content.replace("<head>", base) + runInResult;

        component.dom.querySelector("iframe").setAttribute("srcdoc", "");
        // component.dom.querySelector("iframe").setAttribute("src", "about:blank");

        component.dom.querySelector("iframe").addEventListener("load", function bas() {
          console.log("load");
          component.dom.querySelector("iframe").removeEventListener("load", bas);
          //component.dom.querySelector("iframe").removeAttribute("src");
          component.dom.querySelector("iframe").contentWindow.document.write(blobs["index.html"].content);
          // rever url
          data.urlHistory = [data.urlHistory[0]];
          data.url = data.urlHistory[0];
          data.currentUrlIndex = 1;
        });

      },
      rewriteGet(filename, content) {
        var regex = /(?<!\/\/(\s+)?)get\((\[)?([\s\S]*?)?(.*)\)(\;)?/gm;
        var regex2 = /(?<!\/\/(\s+)?)get\((\[)?([\s\S]*?)?(.*)\)(\;)?/gm;
        var blobs = "";
        let m;
        let mm;

        if (!component.files) {
          component.files = [];
        }

        if (!component.files[i]) {
          component.files[filename] = {};
        }

        while ((m = regex.exec(content)) !== null) {

          // This is necessary to avoid infinite loops with zero-width matches
          if (m.index === regex.lastIndex) {
            regex.lastIndex++;
          }

          if (m[3].indexOf(",") > -1) {

            var f = m[3].replace(/((\\n)|[\\\s\"\[\]])/g, "");
            var fns = f.split(",");
            for (let i = 0; i < fns.length; i++) {
              const fn = fns[i].replace(/\'\"/g, '');
              var nestedComponentContent = component.editors[fn].getValue();

              while ((mm = regex2.exec(content)) !== null) {
                var nnestedComponentContent = component.editors[fn].getValue();;
                component.methods.rewriteGet(fn, nnestedComponentContent);
              }
            }
          }

          else {
            var fn = m[4].slice(0, -1);
            var nestedComponentContent = component.editors[fn].getValue();

            while ((mm = regex2.exec(content)) !== null) {
              var nnestedComponentContent = component.editors[fn].getValue();;
              component.methods.rewriteGet(fn, nnestedComponentContent);
            }
          }
        }

        component.files[filename]["content"] = content;
        component.files[filename]["filename"] = filename;
        return component.files;
      },
      changeSelectedFile(event) {
        var filename = event.target.getAttribute("filename");
        var filenameSelector = filename.replace(/\./g, "\\.");

        for (let i = 0; i < data.files.length; i++) {
          var fn = data.files[i]["filename"];
          if (filename == fn) {
            data.files[i]["selected"] = true;
          }
          else {
            data.files[i]["selected"] = false;
          }
        }

        var targetFile = component.dom.querySelector("#files .CodeMirror[selected=true]");
        var fileItself = component.dom.querySelector("#files .CodeMirror[filename='" + filenameSelector + "']");

        targetFile.setAttribute("selected", false);
        fileItself.setAttribute("selected", true);

        component.editors[filename].refresh();
      },
      addFile() {
        console.log("ekleriz sorun deÄŸil");
      },
      runInResult() {
        window.addEventListener('message', (event) => {
          console.log(`Received message from parent: ${event.data}`);
          window.frameElement.contentWindow.Router.go(event.data);
        });

        window.addEventListener('popstate', function (event) {
          window.parent.postMessage({
            action: "urlChange",
            url: "/" + router.location.pathname
          }, event);
        });

        (function (w) {
          "use strict";

          var A, F, O, consoleMethods, fixConsoleMethod, consoleOn,
            allHandlers, methodObj;

          A = [];
          F = function () { return; };
          O = {};

          // All possible standard methods to provide an interface for
          consoleMethods = [
            "assert", "clear", "count", "debug",
            "dir", "dirxml", "error", "exception",
            "group", "groupCollapsed", "groupEnd",
            "info", "log", "profile", "profileEnd",
            "table", "time", "timeEnd", "timeStamp",
            "trace", "warn"
          ];

          // Holds handlers to be executed for every method
          allHandlers = [];

          // Holds handlers per method
          methodObj = {};

          // Overrides the existing console methods, to call any stored handlers first
          fixConsoleMethod = (function () {
            var func, empty;

            empty = function () {
              return F;
            };

            if (w.console) {
              // If `console` is even available
              func = function (methodName) {
                var old;
                if (methodName in console && (old = console[methodName])) {
                  // Checks to see if `methodName` is defined on `console` and has valid function to execute
                  // (and stores the old handler)
                  // This is important so that undefined methods aren't filled in
                  console[methodName] = function () {
                    // Overwrites current console method with this function
                    var args, argsForAll, i, j;
                    // Copy all arguments passed to handler
                    args = A.slice.call(arguments, 0);
                    for (i = 0, j = methodObj[methodName].handlers.length; i < j; i++) {
                      // Loop over all stored handlers for this specific method and call them
                      F.apply.call(methodObj[methodName].handlers[i], console, args);
                    }
                    for (i = 0, j = allHandlers.length; i < j; i++) {
                      // Loop over all stored handlers for ALL events and call them
                      argsForAll = [methodName];
                      A.push.apply(argsForAll, args);
                      F.apply.call(allHandlers[i], console, argsForAll);
                    }
                    // Calls old
                    F.apply.call(old, console, args);
                  };
                }
                return console[methodName] || empty;
              };
            } else {
              func = empty;
            }

            return func;
          }());

          // Loop through all standard console methods and add a wrapper function that calls stored handlers
          (function () {
            var i, j, cur;
            for (i = 0, j = consoleMethods.length; i < j; i++) {
              // Loop through all valid console methods
              cur = consoleMethods[i];
              methodObj[cur] = {
                handlers: []
              };
              fixConsoleMethod(cur);
            }
          }());

          // Main handler exposed
          consoleOn = function (methodName, callback) {
            var key, cur;
            if (O.toString.call(methodName) === "[object Object]") {
              // Object literal provided as first argument
              for (key in methodName) {
                // Loop through all keys in object literal
                cur = methodName[key];
                if (key === "all") {
                  // If targeting all events
                  allHandlers.push(cur);
                } else if (key in methodObj) {
                  // If targeting specific valid event
                  methodObj[key].handlers.push(cur);
                }
              }
            } else if (typeof methodName === "function") {
              // Function provided as first argument
              allHandlers.push(methodName);
            } else if (methodName in methodObj) {
              // Valid String event provided
              methodObj[methodName].handlers.push(callback);
            }
          };

          // Actually expose an interface
          w.ConsoleListener = {
            on: consoleOn
          };
        }(this));

        ConsoleListener.on(function (methodName, message) {
          window.parent.postMessage({
            action: "console",
            method: methodName,
            message: message
          }, event);
        });
      },
      changeURL(event) {
        var result = component.dom.querySelector("iframe#result").contentWindow;
        if (event.target) {
          var url = event.target.value;
          event.target.blur();
        }
        else {
          var url = event;
        }
        result.postMessage(document.location.pathname + url.replace(/^\//, ''));
      },
      goBack(event) {
        data.currentUrlIndex -= 1;
        var url = data.urlHistory[data.currentUrlIndex - 1];
        component.methods.changeURL(url);
      },
      goNext(event) {
        data.currentUrlIndex += 1;
        var url = data.urlHistory[data.currentUrlIndex - 1];
        component.methods.changeURL(url);
      }
    }
    lifecycle = {
      beforeConstruct() {

      },
      afterFirstRender() {
        // listen messages from child
        window.addEventListener('message', (event) => {
          if (event.data.action == "urlChange") {
            data.url = event.data.url.replace(document.location.pathname, "");
            if (data.url !== data.urlHistory[data.currentUrlIndex - 1]) {
              data.urlHistory = data.urlHistory.slice(0, data.currentUrlIndex);
              data.urlHistory.push(data.url);
              data.currentUrlIndex += 1;
            };
          }
          else if (event.data.action == "console") {
            var method = event.data.method;
            var message = event.data.message;
            console.log(method, message);
          }
        });

        if (typeof CodeMirror == "undefined") {
          loadJS("https://cdn.jsdelivr.net/combine/npm/codemirror@5.62.0/lib/codemirror.min.js,npm/codemirror@5.62.0/mode/javascript/javascript.min.js,npm/codemirror@5.62.0/mode/css/css.min.js,npm/codemirror@5.62.0/mode/xml/xml.min.js,npm/codemirror@5.62.0/mode/htmlmixed/htmlmixed.min.js,npm/codemirror@5.62.0/addon/display/autorefresh.min.js,npm/codemirror-formatting@1.0.0/formatting.min.js,npm/jszip@3.1.5/dist/jszip.min.js", function () {
            var slot = component.dom.querySelector('slot[name=files]');
            var files = slot.assignedNodes()[0].querySelectorAll("textarea");
            component.editors = [];
            for (let index = 0; index < files.length; index++) {
              var fileEl = files[index];
              var filename = fileEl.getAttribute("filename");
              var fileContent = fileEl.value;
              var isFileSelected = fileEl.hasAttribute("selected");
              data.files.push({
                filename: filename,
                selected: isFileSelected
              });
            }

            for (let index = 0; index < files.length; index++) {
              var textarea = files[index];
              var filename = files[index].getAttribute("filename");
              var selected = files[index].hasAttribute("selected");
              var targetEl = component.dom.querySelector("ul#files");

              // remove unnecessary indents
              var indent = textarea.value.split('\n').join('').match(/^\s*/)[0].length;
              var text = textarea.value.trim();
              var a = new RegExp("^\\s{" + indent + "}", "gm");
              text = text.replace(a, "");

              component.editors[textarea.getAttribute("filename")] = CodeMirror(function (node) {
                node.setAttribute("filename", filename);
                node.setAttribute("selected", selected);
                targetEl.appendChild(node, targetEl);
              }, {
                value: text,
                autoRefresh: { delay: 0 },
                lineNumbers: true,
                smartIndent: true,
                mode: "htmlmixed",
                theme: 'default' // ambiance, ayu-mirage, cobalt, dracula, material, rubyblue, nord
              });


              component.editors[textarea.getAttribute("filename")].on("change", function () {
                component.methods.renderResult();
              });
            }

            component.methods.renderResult();

            var cmInitCheck = setInterval(() => {
              var px = parseInt(component.dom.querySelector(".CodeMirror[selected=true] > div:first-child").style.left.replace("px", ""));
              if (px > 100) {
                component.editors["index.html"].refresh();
              }
              else {
                clearInterval(cmInitCheck);
              }
            }, 10);
          })
        }
      },
    }
  }
</script>